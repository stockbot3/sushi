<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Sushi - Avatar Commentary</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Local Libraries -->
  <script src="/lib/pixi.min.js"></script>
  <script src="/lib/cubism4.min.js"></script>
  <script src="/lib/index.min.js"></script>
  
  <!-- Piper TTS -->
  <script type="module">
    import * as piper from 'https://cdn.jsdelivr.net/npm/@piper-tts/web@1.0.0/+esm';
    window.Piper = piper;
  </script>
  
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; background: #0a0a0f; color: white; font-family: 'Inter', sans-serif; overflow: hidden; }
    
    @media (orientation: portrait) {
      .avatar-stage { flex-direction: column; justify-content: center; align-items: center; }
      .avatar-wrapper { width: 90vw; height: 50vh; }
      .avatar-wrapper.hidden-portrait { display: none !important; }
      .vs-badge { display: none !important; }
      .avatar-switcher { display: flex !important; }
    }
    
    @media (orientation: landscape) {
      .avatar-stage { flex-direction: row; justify-content: center; align-items: flex-end; gap: 40px; }
      .avatar-wrapper { width: 45vw; height: 70vh; max-width: 400px; }
      .avatar-wrapper.hidden-portrait { display: flex !important; }
      .vs-badge { display: flex !important; }
      .avatar-switcher { display: none !important; }
    }
    
    .avatar-stage { display: flex; padding: 20px; min-height: 60vh; position: relative; }
    .avatar-wrapper { position: relative; display: flex; flex-direction: column; align-items: center; transition: all 0.3s ease; }
    .avatar-wrapper.speaking { transform: scale(1.05); filter: drop-shadow(0 0 30px rgba(255,184,28,0.4)); z-index: 10; }
    .avatar-canvas { width: 100%; height: 100%; border-radius: 16px; }
    .avatar-info { text-align: center; margin-top: 12px; padding: 12px 24px; background: rgba(255,255,255,0.05); border-radius: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
    .lip-sync-container { width: 100%; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 8px; overflow: hidden; }
    .lip-sync-bar { height: 100%; background: linear-gradient(90deg, #FFB81C, #FF6B35); width: 0%; transition: width 0.05s linear; }
    .vs-badge { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 60px; height: 60px; background: linear-gradient(135deg, #FFB81C, #FF6B35); border-radius: 50%; align-items: center; justify-content: center; font-weight: 900; font-size: 14px; color: #000; z-index: 5; }
    .subtitle-box { text-align: center; padding: 20px; background: rgba(0,0,0,0.5); border-top: 1px solid rgba(255,255,255,0.1); min-height: 100px; }
    .controls-bar { display: flex; justify-content: center; gap: 12px; padding: 16px; background: rgba(255,255,255,0.03); border-top: 1px solid rgba(255,255,255,0.06); }
    .control-btn { padding: 12px 24px; border-radius: 12px; border: none; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.2s; }
    .control-btn.primary { background: linear-gradient(135deg, #FFB81C, #FF6B35); color: #000; }
    .control-btn.secondary { background: rgba(255,255,255,0.1); color: white; }
    .control-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .avatar-switcher { position: fixed; bottom: 140px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 8px; border-radius: 24px; gap: 8px; z-index: 100; }
    .switcher-dot { width: 12px; height: 12px; border-radius: 50%; background: rgba(255,255,255,0.3); cursor: pointer; transition: all 0.2s; }
    .switcher-dot.active { transform: scale(1.2); }
    .ios-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; cursor: pointer; }
    .loading-overlay { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.9); border-radius: 16px; z-index: 20; }
    .spinner { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-top-color: #FFB81C; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .error-box { color: #ff4444; text-align: center; padding: 20px; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // Check if libraries loaded
    const hasPixi = typeof window.PIXI !== 'undefined';
    const hasLive2D = hasPixi && window.PIXI.live2d;
    
    console.log('PIXI loaded:', hasPixi);
    console.log('Live2D loaded:', hasLive2D);

    // Piper TTS Engine
    class PiperTTSEngine {
      constructor() {
        this.piper = null;
        this.audioContext = null;
        this.isReady = false;
      }
      
      async init() {
        try {
          // Initialize AudioContext (required for iOS)
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          if (this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
          }
          
          // Load Piper
          if (window.Piper) {
            this.piper = new window.Piper.Piper();
            await this.piper.loadVoice('en_US-lessac');
            this.isReady = true;
            console.log('Piper TTS ready');
          } else {
            console.warn('Piper not available, using fallback');
          }
        } catch (err) {
          console.error('TTS init error:', err);
        }
      }
      
      async speak(text, onLipSync) {
        if (!this.isReady || !this.piper) {
          // Fallback to Web Speech
          return this._speakFallback(text, onLipSync);
        }
        
        try {
          // Generate speech with Piper
          const audioData = await this.piper.synthesize(text);
          
          // Create audio buffer
          const audioBuffer = await this.audioContext.decodeAudioData(audioData.buffer.slice(0));
          
          // Create source and analyser
          const source = this.audioContext.createBufferSource();
          const analyser = this.audioContext.createAnalyser();
          analyser.fftSize = 256;
          
          source.buffer = audioBuffer;
          source.connect(analyser);
          analyser.connect(this.audioContext.destination);
          
          // Start playback
          source.start(0);
          
          // Analyze audio for lip-sync
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          let isPlaying = true;
          
          source.onended = () => {
            isPlaying = false;
            if (onLipSync) onLipSync(0);
          };
          
          // Lip-sync loop
          const analyze = () => {
            if (!isPlaying) {
              if (onLipSync) onLipSync(0);
              return;
            }
            
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
            const normalized = average / 255;
            
            if (onLipSync) onLipSync(normalized);
            
            requestAnimationFrame(analyze);
          };
          
          analyze();
          
          // Return promise that resolves when done
          return new Promise((resolve) => {
            source.onended = () => {
              isPlaying = false;
              if (onLipSync) onLipSync(0);
              resolve();
            };
          });
          
        } catch (err) {
          console.error('Piper speak error:', err);
          return this._speakFallback(text, onLipSync);
        }
      }
      
      _speakFallback(text, onLipSync) {
        return new Promise((resolve) => {
          const synth = window.speechSynthesis;
          synth.cancel();
          
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 1.0;
          utterance.pitch = 1.0;
          
          let interval;
          if (onLipSync) {
            interval = setInterval(() => {
              onLipSync(0.3 + Math.random() * 0.5);
            }, 80);
          }
          
          utterance.onend = () => {
            clearInterval(interval);
            if (onLipSync) onLipSync(0);
            resolve();
          };
          
          utterance.onerror = () => {
            clearInterval(interval);
            if (onLipSync) onLipSync(0);
            resolve();
          };
          
          synth.speak(utterance);
        });
      }
      
      stop() {
        if (this.audioContext) {
          this.audioContext.suspend();
          this.audioContext.resume();
        }
        window.speechSynthesis.cancel();
      }
    }

    // Live2D Avatar Component
    function Live2DAvatar({ modelPath, name, teamColor, isSpeaking, lipSyncValue, onClick }) {
      const containerRef = useRef(null);
      const [isLoading, setIsLoading] = useState(true);
      const [error, setError] = useState(null);
      const modelRef = useRef(null);
      const appRef = useRef(null);
      const lipSyncTarget = useRef(0);
      
      useEffect(() => {
        lipSyncTarget.current = lipSyncValue;
      }, [lipSyncValue]);
      
      useEffect(() => {
        if (!hasPixi || !hasLive2D) {
          setError('Live2D libraries not loaded');
          setIsLoading(false);
          return;
        }
        
        const { Live2DModel } = window.PIXI.live2d;
        let app;
        let model;
        
        const loadModel = async () => {
          try {
            // Create PIXI Application
            app = new PIXI.Application({
              width: 400,
              height: 500,
              transparent: true,
              antialias: true,
              resolution: window.devicePixelRatio || 1,
              autoDensity: true
            });
            
            appRef.current = app;
            containerRef.current.appendChild(app.view);
            
            // Load Live2D model
            console.log('Loading Live2D model:', modelPath);
            model = await Live2DModel.from(modelPath);
            modelRef.current = model;
            
            // Add to stage
            app.stage.addChild(model);
            
            // Position
            model.anchor.set(0.5, 0.5);
            model.x = 200;
            model.y = 250;
            model.scale.set(0.4);
            
            // Enable interactions
            model.eventMode = 'static';
            model.on('pointerdown', onClick);
            
            // Animation loop
            app.ticker.add(() => {
              if (model && model.internalModel) {
                // Apply lip-sync to mouth parameter
                const currentMouth = model.internalModel.coreModel.getParamValue('ParamMouthOpenY') || 0;
                const targetMouth = lipSyncTarget.current;
                const smoothed = currentMouth + (targetMouth - currentMouth) * 0.4;
                model.internalModel.coreModel.setParamValue('ParamMouthOpenY', smoothed);
                
                // Breathing animation
                const time = Date.now() / 1000;
                const breath = Math.sin(time * 2) * 0.5 + 0.5;
                model.internalModel.coreModel.setParamValue('ParamBreath', breath * 0.3);
                
                // Eye tracking (subtle random movement)
                const eyeX = Math.sin(time * 0.5) * 0.3;
                const eyeY = Math.cos(time * 0.7) * 0.2;
                model.internalModel.coreModel.setParamValue('ParamEyeBallX', eyeX);
                model.internalModel.coreModel.setParamValue('ParamEyeBallY', eyeY);
              }
            });
            
            setIsLoading(false);
            console.log('Live2D model loaded:', name);
            
          } catch (err) {
            console.error('Live2D load error:', err);
            setError(err.message);
            setIsLoading(false);
          }
        };
        
        loadModel();
        
        return () => {
          if (app) app.destroy(true);
        };
      }, [modelPath, name, onClick]);
      
      return (
        <div className={`avatar-wrapper ${isSpeaking ? 'speaking' : ''}`} onClick={onClick}>
          {isLoading && (
            <div className="loading-overlay">
              <div className="spinner"></div>
              <div className="text-gray-400 mt-4 text-sm">Loading {name}...</div>
            </div>
          )}
          
          {error && (
            <div className="loading-overlay">
              <div className="error-box">
                <div className="text-sm">Failed to load avatar</div>
                <div className="text-xs mt-2 text-gray-500">{error}</div>
              </div>
            </div>
          )}
          
          <div ref={containerRef} className="avatar-canvas" />
          
          <div className="avatar-info">
            <div style={{ color: teamColor, fontWeight: 700, fontSize: '16px' }}>{name}</div>
            <div className="text-gray-400 text-xs mt-1">{isSpeaking ? 'Speaking...' : 'Listening'}</div>
            <div className="lip-sync-container">
              <div className="lip-sync-bar" style={{ width: `${lipSyncValue * 100}%` }} />
            </div>
          </div>
        </div>
      );
    }

    // Main App
    function App() {
      const [session, setSession] = useState(null);
      const [commentary, setCommentary] = useState([]);
      const [isPlaying, setIsPlaying] = useState(false);
      const [lipSyncA, setLipSyncA] = useState(0);
      const [lipSyncB, setLipSyncB] = useState(0);
      const [currentSpeaker, setCurrentSpeaker] = useState(null);
      const [subtitle, setSubtitle] = useState({ speaker: '', text: 'Tap Play to start' });
      const [showIOSStart, setShowIOSStart] = useState(true);
      const [activeAvatar, setActiveAvatar] = useState('A');
      const [isLandscape, setIsLandscape] = useState(window.innerWidth > window.innerHeight);
      const [libsLoaded, setLibsLoaded] = useState(hasPixi && hasLive2D);
      
      const ttsRef = useRef(new PiperTTSEngine());
      const isPlayingRef = useRef(false);
      
      useEffect(() => {
        isPlayingRef.current = isPlaying;
      }, [isPlaying]);
      
      useEffect(() => {
        // Check library loading
        const checkLibs = setInterval(() => {
          if (typeof window.PIXI !== 'undefined' && window.PIXI.live2d) {
            setLibsLoaded(true);
            clearInterval(checkLibs);
          }
        }, 500);
        
        setTimeout(() => clearInterval(checkLibs), 10000);
        
        const handleResize = () => {
          setIsLandscape(window.innerWidth > window.innerHeight);
        };
        
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', handleResize);
        
        return () => {
          clearInterval(checkLibs);
          window.removeEventListener('resize', handleResize);
          window.removeEventListener('orientationchange', handleResize);
        };
      }, []);
      
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const sessionId = params.get('session');
        if (sessionId) {
          fetch(`/api/sessions/${sessionId}`)
            .then(r => r.json())
            .then(data => setSession(data))
            .catch(console.error);
        }
      }, []);
      
      const handleIOSStart = async () => {
        await ttsRef.current.init();
        setShowIOSStart(false);
      };
      
      const playCommentary = async () => {
        const params = new URLSearchParams(window.location.search);
        const sessionId = params.get('session');
        
        if (!sessionId) return;
        
        try {
          const res = await fetch(`/api/sessions/${sessionId}/commentary/latest`);
          const data = await res.json();
          
          if (data.turns && data.turns.length > 0) {
            setCommentary(data.turns);
            setIsPlaying(true);
            playTurn(0, data.turns);
          } else {
            setSubtitle({ speaker: '', text: 'No commentary yet. Try again soon.' });
          }
        } catch (err) {
          setSubtitle({ speaker: 'Error', text: 'Failed to load commentary' });
        }
      };
      
      const playTurn = async (index, turns) => {
        if (index >= turns.length || !isPlayingRef.current) {
          setIsPlaying(false);
          setCurrentSpeaker(null);
          setLipSyncA(0);
          setLipSyncB(0);
          setSubtitle({ speaker: '', text: 'Commentary complete' });
          return;
        }
        
        const turn = turns[index];
        setCurrentSpeaker(turn.speaker);
        setSubtitle({ speaker: turn.name, text: turn.text });
        
        if (!isLandscape) {
          setActiveAvatar(turn.speaker);
        }
        
        await ttsRef.current.speak(turn.text, (intensity) => {
          if (turn.speaker === 'A') {
            setLipSyncA(intensity);
            setLipSyncB(0);
          } else {
            setLipSyncB(intensity);
            setLipSyncA(0);
          }
        });
        
        // Ensure lip-sync stops
        setLipSyncA(0);
        setLipSyncB(0);
        
        await new Promise(r => setTimeout(r, 500));
        
        if (isPlayingRef.current) {
          playTurn(index + 1, turns);
        }
      };
      
      const handlePause = () => {
        setIsPlaying(false);
        ttsRef.current.stop();
        setLipSyncA(0);
        setLipSyncB(0);
      };
      
      const handleSkip = () => {
        ttsRef.current.stop();
      };
      
      const commentatorA = session?.commentators?.[0] || { name: 'Hiyori', team: 'away' };
      const commentatorB = session?.commentators?.[1] || { name: 'Ren', team: 'home' };
      
      const getTeamColor = (team) => team === 'home' ? '#4a90d9' : '#ff6b35';
      
      if (!libsLoaded) {
        return (
          <div className="h-screen flex flex-col items-center justify-center bg-black">
            <div className="spinner"></div>
            <div className="text-gray-400 mt-4">Loading Live2D libraries...</div>
          </div>
        );
      }
      
      return (
        <div className="h-screen flex flex-col">
          {showIOSStart && (
            <div className="ios-overlay" onClick={handleIOSStart}>
              <div className="text-6xl mb-4">üéôÔ∏è</div>
              <h1 className="text-2xl font-bold mb-2">Avatar Commentary</h1>
              <p className="text-gray-400 mb-8">Tap anywhere to start</p>
              <div className="text-sm text-gray-500">Enables audio on iOS</div>
            </div>
          )}
          
          <div className="bg-white/5 border-b border-white/10 p-4 flex items-center justify-between">
            <a href="/" className="text-gray-400 hover:text-white text-2xl">‚Üê</a>
            <div className="text-center">
              <div className="font-bold">Avatar Mode</div>
              <div className="text-xs text-gray-400">{session?.gameName || 'Live Commentary'}</div>
            </div>
            <div className="w-6"></div>
          </div>
          
          <div className="avatar-stage flex-1">
            <div className="vs-badge">VS</div>
            
            <div className={`avatar-wrapper ${!isLandscape && activeAvatar !== 'A' ? 'hidden-portrait' : ''}`}>
              <Live2DAvatar
                modelPath="/avatars/models/hiyori/hiyori_pro_t11.model3.json"
                name={commentatorA.name}
                teamColor={getTeamColor(commentatorA.team)}
                isSpeaking={currentSpeaker === 'A'}
                lipSyncValue={lipSyncA}
                onClick={() => setActiveAvatar('A')}
              />
            </div>
            
            <div className={`avatar-wrapper ${!isLandscape && activeAvatar !== 'B' ? 'hidden-portrait' : ''}`}>
              <Live2DAvatar
                modelPath="/avatars/models/ren/ren.model3.json"
                name={commentatorB.name}
                teamColor={getTeamColor(commentatorB.team)}
                isSpeaking={currentSpeaker === 'B'}
                lipSyncValue={lipSyncB}
                onClick={() => setActiveAvatar('B')}
              />
            </div>
          </div>
          
          <div className="avatar-switcher">
            <div 
              className={`switcher-dot ${activeAvatar === 'A' ? 'active' : ''}`}
              onClick={() => setActiveAvatar('A')}
              style={{ background: activeAvatar === 'A' ? getTeamColor(commentatorA.team) : undefined }}
            />
            <div 
              className={`switcher-dot ${activeAvatar === 'B' ? 'active' : ''}`}
              onClick={() => setActiveAvatar('B')}
              style={{ background: activeAvatar === 'B' ? getTeamColor(commentatorB.team) : undefined }}
            />
          </div>
          
          <div className="subtitle-box">
            <div className="text-yellow-400 text-xs font-bold uppercase tracking-wider mb-1">
              {subtitle.speaker || 'Commentary'}
            </div>
            <div className="text-lg font-medium text-white/90">
              {subtitle.text}
            </div>
          </div>
          
          <div className="controls-bar">
            {!isPlaying ? (
              <button className="control-btn primary" onClick={playCommentary}>
                ‚ñ∂ Play
              </button>
            ) : (
              <button className="control-btn secondary" onClick={handlePause}>
                ‚è∏ Pause
              </button>
            )}
            <button className="control-btn secondary" onClick={handleSkip}>
              ‚è≠ Skip
            </button>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
