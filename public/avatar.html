<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sushi - VRM Animation Fix</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000; color: #fff; overflow: hidden; height: 100vh;
        }
        #root { width: 100%; height: 100%; position: relative; }
        
        .stream-hud {
            position: absolute; top: 0; left: 0; right: 0; z-index: 100;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            padding: 20px;
        }
        .hud-scores { display: flex; align-items: center; justify-content: center; gap: 20px; }
        .hud-team { display: flex; flex-direction: column; align-items: center; min-width: 80px; }
        .hud-abbr { font-size: 12px; font-weight: 900; opacity: 0.6; }
        .hud-pts { font-size: 48px; font-weight: 900; line-height: 1; }
        .hud-sep { font-size: 24px; opacity: 0.2; }

        .vrm-stage {
            position: absolute; inset: 0; display: flex;
            background: radial-gradient(circle at 50% 40%, #1a1a2e 0%, #000 100%);
        }
        .vrm-canvas-container { flex: 1; position: relative; }
        .vrm-canvas { width: 100%; height: 100%; display: block; }

        .subtitle-box {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 600px;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.1);
            text-align: center; z-index: 200;
        }
        .subtitle-name { font-size: 10px; font-weight: 900; color: #FFB81C; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px; }
        .subtitle-text { font-size: 18px; line-height: 1.4; color: #fff; }

        .loading-screen {
            position: fixed; inset: 0; z-index: 1000;
            background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .spinner { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-top-color: #FFB81C; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .start-overlay {
            position: fixed; inset: 0; z-index: 500;
            background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center;
            cursor: pointer;
        }
        .start-btn {
            padding: 25px 50px; border-radius: 50px;
            background: #fff; color: #000; font-weight: 900; font-size: 20px;
            box-shadow: 0 10px 30px rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        window.THREE = THREE; window.GLTFLoader = GLTFLoader;
        window.VRMLoaderPlugin = VRMLoaderPlugin; window.VRMUtils = VRMUtils;
        window.modulesLoaded = true; window.dispatchEvent(new Event('modulesLoaded'));
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const SAKURA_URL = 'https://raw.githubusercontent.com/pixiv/three-vrm/release/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
        const YUKI_URL = '/test.glb';

        const events = {
            listeners: [],
            sub(fn) { this.listeners.push(fn); return () => this.listeners = this.listeners.filter(l => l !== fn); },
            emit(side, type, data) { this.listeners.forEach(l => l(side, type, data)); }
        };

        class VoiceService {
            constructor() { this.ctx = null; }
            async init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') await this.ctx.resume();
                
                // FORCE AUDIO UNLOCK FOR iOS
                const b = this.ctx.createBuffer(1, 1, 22050);
                const s = this.ctx.createBufferSource(); s.buffer = b;
                s.connect(this.ctx.destination); s.start(0);
                
                // FORCE SPEECH UNLOCK
                const u = new SpeechSynthesisUtterance(" ");
                window.speechSynthesis.speak(u);
            }
            async speak(text, side, voiceId) {
                await this.init();
                try {
                    const res = await fetch('/api/tts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text, voiceId })
                    });
                    const data = await res.json();
                    if (!data.audio) throw new Error();
                    
                    const bin = atob(data.audio.replace(/\s/g, ''));
                    const buf = new Uint8Array(bin.length);
                    for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
                    
                    const ad = await this.ctx.decodeAudioData(buf.buffer);
                    const src = this.ctx.createBufferSource(); src.buffer = ad;
                    const ana = this.ctx.createAnalyser(); ana.fftSize = 256;
                    src.connect(ana); ana.connect(this.ctx.destination);
                    
                    const dat = new Uint8Array(ana.frequencyBinCount);
                    const dur = ad.duration * 1000; const start = Date.now();
                    return new Promise(resolve => {
                        const loop = () => {
                            if (Date.now() - start > dur) return;
                            ana.getByteFrequencyData(dat);
                            let avg = 0; for(let i=0; i<dat.length; i++) avg += dat[i];
                            avg /= dat.length;
                            events.emit(side, 'vis', { v: avg > 20 ? ['aa','ih','ou','E','oh'][Math.floor(Math.random()*5)] : 'sil', vol: avg/255 });
                            requestAnimationFrame(loop);
                        };
                        src.onended = () => { events.emit(side, 'vis', { v: 'sil', vol: 0 }); resolve(); };
                        src.start(0); loop();
                    });
                } catch (e) {
                    console.warn("TTS Failed, using system voice", e);
                    return new Promise(r => {
                        const u = new SpeechSynthesisUtterance(text);
                        u.onboundary = (ev) => {
                            if (ev.name === 'word') {
                                events.emit(side, 'vis', { v: 'aa', vol: 0.5 });
                                setTimeout(() => events.emit(side, 'vis', { v: 'sil', vol: 0 }), 100);
                            }
                        };
                        u.onend = r; window.speechSynthesis.speak(u);
                    });
                }
            }
        }

        function Avatar({ side, modelUrl, activeSpeaker }) {
            const canvasRef = useRef(null);
            const vrmRef = useRef(null);
            const fallbackBonesRef = useRef({});
            const speakerRef = useRef(activeSpeaker);
            const [loaded, setLoaded] = useState(false);

            useEffect(() => { speakerRef.current = activeSpeaker; }, [activeSpeaker]);

            useEffect(() => {
                let mounted = true;
                const init = () => {
                    const { THREE, GLTFLoader, VRMLoaderPlugin, VRMUtils } = window;
                    const scene = new THREE.Scene();
                    const cam = new THREE.PerspectiveCamera(35, canvasRef.current.clientWidth / canvasRef.current.clientHeight, 0.1, 1000);
                    cam.position.set(0, 1.4, 3.8); cam.lookAt(0, 1.3, 0);
                    const ren = new THREE.WebGLRenderer({ canvas: canvasRef.current, alpha: true, antialias: true });
                    ren.setSize(canvasRef.current.clientWidth, canvasRef.current.clientHeight);
                    ren.setPixelRatio(window.devicePixelRatio);
                    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
                    const l = new THREE.DirectionalLight(0xffffff, 1.5); l.position.set(1, 2, 3); scene.add(l);

                    const loader = new GLTFLoader();
                    loader.register(p => new VRMLoaderPlugin(p));
                    loader.load(modelUrl, gltf => {
                        if (!mounted) return;
                        const vrm = gltf.userData.vrm;
                        if (vrm) {
                            vrmRef.current = vrm; VRMUtils.rotateVRM0(vrm); scene.add(vrm.scene);
                        } else {
                            // Non-VRM (Standard GLTF like test.glb)
                            scene.add(gltf.scene);
                            const bones = {};
                            gltf.scene.traverse(obj => {
                                if (obj.isBone || obj.type === 'Group' || obj.type === 'Object3D') {
                                    const n = obj.name.toLowerCase();
                                    if (n.includes('leftupperarm') || n.includes('leftarm')) bones.lua = obj;
                                    if (n.includes('rightupperarm') || n.includes('rightarm')) bones.rua = obj;
                                    if (n.includes('leftlowerarm') || n.includes('leftforearm')) bones.lla = obj;
                                    if (n.includes('rightlowerarm') || n.includes('rightforearm')) bones.rla = obj;
                                    if (n.includes('spine')) bones.spine = obj;
                                    if (n.includes('head')) bones.head = obj;
                                }
                            });
                            fallbackBonesRef.current = bones;
                        }
                        setLoaded(true);
                    });

                    const clock = new THREE.Clock();
                    const animate = () => {
                        if (!mounted) return; requestAnimationFrame(animate);
                        const t = clock.getElapsedTime(); const d = clock.getDelta();
                        
                        let h = null;
                        let lua, rua, lla, rla, spine, head;

                        if (vrmRef.current) {
                            vrmRef.current.update(d);
                            h = vrmRef.current.humanoid;
                            if (h) {
                                lua = h.getNormalizedBoneNode('leftUpperArm');
                                rua = h.getNormalizedBoneNode('rightUpperArm');
                                lla = h.getNormalizedBoneNode('leftLowerArm');
                                rla = h.getNormalizedBoneNode('rightLowerArm');
                                spine = h.getNormalizedBoneNode('spine');
                                head = h.getNormalizedBoneNode('head');
                            }
                        } else {
                            const fb = fallbackBonesRef.current;
                            lua = fb.lua; rua = fb.rua; lla = fb.lla; rla = fb.rla; spine = fb.spine; head = fb.head;
                        }

                        // Apply natural pose and animation
                        if (lua && rua) {
                            if (speakerRef.current === side) {
                                // SPEAKING: Bend elbows and move arms naturally
                                const targetZ = side === 'left' ? -1.1 : 1.1;
                                lua.rotation.z = THREE.MathUtils.lerp(lua.rotation.z, targetZ + Math.sin(t * 3) * 0.1, 0.1);
                                rua.rotation.z = THREE.MathUtils.lerp(rua.rotation.z, -targetZ + Math.cos(t * 3) * 0.1, 0.1);
                                
                                lua.rotation.x = -0.4 + Math.sin(t * 5) * 0.2;
                                rua.rotation.x = -0.4 + Math.cos(t * 5) * 0.2;

                                // BEND ELBOWS
                                if (lla) lla.rotation.x = -0.8 + Math.sin(t * 8) * 0.3;
                                if (rla) rla.rotation.x = -0.8 + Math.cos(t * 8) * 0.3;
                                
                                if (head) {
                                    head.rotation.x = Math.sin(t * 15) * 0.05; // Emphasis bob
                                    head.rotation.y += Math.sin(t * 2) * 0.02;
                                }
                                if (spine) spine.rotation.x = 0.1; // Lean in
                            } else {
                                // IDLE / LISTENING: Relaxed A-pose
                                const relaxZ = side === 'left' ? -1.4 : 1.4;
                                lua.rotation.z = THREE.MathUtils.lerp(lua.rotation.z, relaxZ, 0.05);
                                rua.rotation.z = THREE.MathUtils.lerp(rua.rotation.z, -relaxZ, 0.05);
                                lua.rotation.x = THREE.MathUtils.lerp(lua.rotation.x, 0, 0.05);
                                rua.rotation.x = THREE.MathUtils.lerp(rua.rotation.x, 0, 0.05);
                                
                                // ELBOWS RELAXED
                                if (lla) lla.rotation.x = THREE.MathUtils.lerp(lla.rotation.x, -0.2, 0.05);
                                if (rla) rla.rotation.x = THREE.MathUtils.lerp(rla.rotation.x, -0.2, 0.05);

                                if (head) {
                                    const lookAtPartner = side === 'left' ? 0.4 : -0.4;
                                    head.rotation.y = THREE.MathUtils.lerp(head.rotation.y, lookAtPartner + Math.sin(t * 0.5) * 0.05, 0.05);
                                }
                                if (spine) {
                                    spine.rotation.x = THREE.MathUtils.lerp(spine.rotation.x, 0, 0.05);
                                    spine.position.y = Math.sin(t * 1.2) * 0.01; // Breathe
                                }
                            }
                        }

                        if (vrmRef.current?.expressionManager) {
                            vrmRef.current.expressionManager.setValue('blink', (t % 5 < 0.15) ? 1 : 0);
                        }
                        
                        ren.render(scene, cam);
                    };
                    animate();
                };
                if (window.modulesLoaded) init(); else window.addEventListener('modulesLoaded', init);
                return () => mounted = false;
            }, [side, modelUrl]);

            useEffect(() => {
                return events.sub((s, type, data) => {
                    if (s !== side || !vrmRef.current?.expressionManager) return;
                    const m = vrmRef.current.expressionManager, map = m._expressionMap;
                    if (type === 'vis') {
                        ['aa','ih','ou','E','oh','a','i','u','e','o'].forEach(v => { if (v in map) m.setValue(v, 0); });
                        if (data.v !== 'sil') {
                            let t = data.v;
                            if (!(t in map)) { const f = { 'aa':'a','ih':'i','ou':'u','E':'e','oh':'o' }; t = f[data.v] || data.v[0]; }
                            if (!(t in map)) t = t.toUpperCase();
                            if (t in map) m.setValue(t, data.vol * 2.5);
                        }
                        m.update();
                    }
                });
            }, [side]);

            return <div className="vrm-canvas-container"><canvas ref={canvasRef} className="vrm-canvas" /></div>;
        }

        function App() {
            const [started, setStarted] = useState(false);
            const [game, setGame] = useState(null);
            const [activeSpeaker, setActiveSpeaker] = useState(null);
            const [sub, setSub] = useState({ name: "", text: "" });
            const voice = useRef(new VoiceService());
            const lastSeq = useRef(-1);
            const voiced = useRef(new Set());

            const run = async (turns) => {
                for (const t of turns) {
                    const side = t.speaker === 'A' ? 'left' : 'right';
                    const vid = side === 'left' ? '21m00Tcm4TlvDq8ikWAM' : 'ErXwobaYiN019PkySvjV';
                    setSub({ name: t.name, text: t.text });
                    setActiveSpeaker(side);
                    await voice.current.speak(t.text, side, vid);
                    setActiveSpeaker(null); setSub({ name: "", text: "" });
                    await new Promise(r => setTimeout(r, 1000));
                }
            };

            useEffect(() => {
                if (!started) return;
                const sid = new URLSearchParams(window.location.search).get('session');
                const poll = async () => {
                    try {
                        const [g, c] = await Promise.all([
                            fetch(`/api/sessions/${sid}/game`).then(r => r.json()),
                            fetch(`/api/sessions/${sid}/commentary/latest`).then(r => r.json())
                        ]);
                        setGame(g);
                        const seq = c.play?.seq || c.timestamp;
                        const pid = c.play?.description || c.timestamp;
                        if (seq !== lastSeq.current && !voiced.current.has(pid)) {
                            lastSeq.current = seq; voiced.current.add(pid);
                            run(c.turns);
                        }
                    } catch (e) {}
                };
                poll(); const itv = setInterval(poll, 10000); return () => clearInterval(itv);
            }, [started]);

            if (!started) return <div className="start-overlay" onClick={async () => { await voice.current.init(); setStarted(true); }}><div className="start-btn">START CINEMATIC STREAM</div></div>;

            return (
                <div id="root">
                    <div className="stream-hud">
                        <div className="hud-scores">
                            <div className="hud-team">
                                <span className="hud-abbr">{game?.away?.abbreviation}</span>
                                <span className="hud-pts">{game?.away?.score}</span>
                            </div>
                            <span className="hud-sep">VS</span>
                            <div className="hud-team">
                                <span className="hud-abbr">{game?.home?.abbreviation}</span>
                                <span className="hud-pts">{game?.home?.score}</span>
                            </div>
                        </div>
                    </div>
                    <div className="vrm-stage">
                        <Avatar side="left" modelUrl={SAKURA_URL} activeSpeaker={activeSpeaker} />
                        <Avatar side="right" modelUrl={YUKI_URL} activeSpeaker={activeSpeaker} />
                    </div>
                    {sub.text && (
                        <div className="subtitle-box">
                            <div className="subtitle-name">{sub.name}</div>
                            <div className="subtitle-text">{sub.text}</div>
                        </div>
                    )}
                </div>
            );
        }
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
