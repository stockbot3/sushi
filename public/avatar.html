<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sushi - VRM Commentary Avatars</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        #root { width: 100%; height: 100%; }
        .vrm-container {
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
        }
        .vrm-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 20px;
            background: rgba(20, 20, 35, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10; backdrop-filter: blur(10px);
        }
        .vrm-header h1 {
            font-size: 20px; font-weight: 600;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .vrm-header button {
            padding: 8px 16px; border: none; border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: #fff;
            cursor: pointer; font-size: 14px; transition: all 0.2s;
        }
        .vrm-header button:hover { background: rgba(255, 255, 255, 0.2); }
        .vrm-header button.active {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000; font-weight: 600;
        }
        .vrm-stage {
            flex: 1; display: flex; position: relative; overflow: hidden;
        }
        .vrm-canvas-container {
            flex: 1; position: relative; overflow: hidden;
        }
        .vrm-canvas-container.dual {
            width: 50%;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        .vrm-canvas-container.dual:last-child { border-right: none; }
        .vrm-canvas { width: 100%; height: 100%; display: block; }
        
        .avatar-overlay {
            position: absolute; bottom: 0; left: 0; right: 0;
            padding: 20px;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            pointer-events: none;
        }
        .avatar-info {
            background: rgba(20, 20, 35, 0.9);
            padding: 12px 16px; border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: inline-block; pointer-events: auto;
        }
        .avatar-info h3 { font-size: 16px; margin-bottom: 4px; color: #feca57; }
        .avatar-info p { font-size: 12px; color: rgba(255, 255, 255, 0.6); }
        
        .avatar-controls {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px;
            align-items: flex-end;
        }
        .expression-palette {
            display: flex; gap: 6px; flex-wrap: wrap;
            justify-content: flex-end; max-width: 220px;
        }
        .expression-palette button {
            padding: 8px 14px; border: none; border-radius: 20px;
            background: rgba(255, 255, 255, 0.1); color: #fff;
            cursor: pointer; font-size: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .expression-palette button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        .expression-palette button.active {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000; font-weight: 600;
        }
        .speak-button {
            padding: 12px 24px; border: none; border-radius: 30px;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000; cursor: pointer; font-size: 14px; font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        .speak-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        .speak-button:disabled {
            opacity: 0.5; cursor: not-allowed; transform: none;
        }
        
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 1000;
        }
        .loading-content { text-align: center; padding: 40px; }
        .loading-spinner {
            width: 80px; height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ff6b6b; border-right-color: #feca57;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 24px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
        .loading-subtext { font-size: 14px; color: rgba(255, 255, 255, 0.5); }
        
        .status-badge {
            position: absolute; top: 20px; left: 20px;
            padding: 6px 12px; border-radius: 20px;
            font-size: 12px; font-weight: 600;
            background: rgba(0, 255, 100, 0.2);
            border: 1px solid rgba(0, 255, 100, 0.4);
            color: #0f0;
        }
        .status-badge.speaking {
            background: rgba(255, 100, 0, 0.2);
            border-color: rgba(255, 100, 0, 0.4);
            color: #fa0;
            animation: pulse 0.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @media (max-aspect-ratio: 3/4) {
            .vrm-stage.dual-mode { flex-direction: column; }
            .vrm-canvas-container.dual {
                width: 100%; height: 50%;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            .vrm-canvas-container.dual:last-child { border-bottom: none; }
            .vrm-header h1 { font-size: 16px; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        
        window.THREE = THREE;
        window.GLTFLoader = GLTFLoader;
        window.VRMLoaderPlugin = VRMLoaderPlugin;
        window.VRMUtils = VRMUtils;
        window.modulesLoaded = true;
        window.dispatchEvent(new Event('modulesLoaded'));
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Working VRM URL - verified with curl
        const VRM_URL = 'https://raw.githubusercontent.com/pixiv/three-vrm/release/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
        
        // Piper TTS Service with real-time lip sync
        class TTSService {
            constructor() {
                this.onViseme = null;
                this.isSpeaking = false;
                this.audioContext = null;
                this.analyser = null;
            }
            
            async initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }
            
            async speak(text) {
                await this.initAudioContext();
                this.isSpeaking = true;
                
                try {
                    // Call Modal Piper TTS API
                    console.log('Calling Modal Piper TTS:', text);
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text }),
                    });
                    
                    if (!response.ok) {
                        throw new Error(`TTS API returned ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Decode base64 audio
                    const audioBytes = atob(data.audio);
                    const arrayBuffer = new ArrayBuffer(audioBytes.length);
                    const view = new Uint8Array(arrayBuffer);
                    for (let i = 0; i < audioBytes.length; i++) {
                        view[i] = audioBytes.charCodeAt(i);
                    }
                    
                    const audioData = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    // Create audio source
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioData;
                    
                    // Create analyser for lip sync
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    
                    // Connect: source -> analyser -> destination
                    source.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
                    
                    // Start lip sync analysis
                    this.startLipSyncAnalysis(text, audioData.duration);
                    
                    // Play audio
                    source.start(0);
                    
                    // Wait for playback to finish
                    await new Promise((resolve) => {
                        source.onended = () => {
                            this.isSpeaking = false;
                            if (this.onViseme) this.onViseme('sil', 0);
                            resolve();
                        };
                    });
                    
                } catch (err) {
                    console.error('Modal TTS failed, falling back to Web Speech:', err);
                    // Fallback to Web Speech API
                    await this.speakWithWebSpeech(text);
                }
            }
            
            startLipSyncAnalysis(text, duration) {
                if (!this.analyser || !this.onViseme) return;
                
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                const words = text.split(/\s+/);
                const startTime = this.audioContext.currentTime;
                const wordsPerSecond = words.length / duration;
                
                const analyze = () => {
                    if (!this.isSpeaking) return;
                    
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    // Calculate volume from frequency data
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i];
                    }
                    const average = sum / dataArray.length;
                    const volume = average / 255;
                    
                    // Map volume to visemes
                    if (volume > 0.15) {
                        const elapsed = this.audioContext.currentTime - startTime;
                        const wordIndex = Math.floor(elapsed * wordsPerSecond);
                        if (wordIndex < words.length) {
                            const word = words[wordIndex];
                            const viseme = this.getVisemeForWord(word);
                            this.onViseme(viseme, 0.1);
                        }
                    } else {
                        this.onViseme('sil', 0.05);
                    }
                    
                    requestAnimationFrame(analyze);
                };
                
                analyze();
            }
            
            getVisemeForWord(word) {
                const char = word.charAt(0).toLowerCase();
                const map = {
                    'a': 'aa', 'e': 'E', 'i': 'ih', 'o': 'oh', 'u': 'ou',
                    'b': 'PP', 'm': 'PP', 'p': 'PP',
                    'f': 'FF', 'v': 'FF',
                    't': 'TH', 'd': 'DD', 's': 'SS',
                    'k': 'kk', 'g': 'kk', 'c': 'kk',
                    'n': 'nn', 'l': 'nn', 'r': 'RR',
                    'w': 'ou', 'y': 'ih'
                };
                return map[char] || 'aa';
            }
            
            async speakWithWebSpeech(text) {
                return new Promise((resolve) => {
                    const synthesis = window.speechSynthesis;
                    if (!synthesis) {
                        this.isSpeaking = false;
                        resolve();
                        return;
                    }
                    
                    synthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.1;
                    utterance.pitch = 1;
                    
                    const voices = synthesis.getVoices();
                    const voice = voices.find(v => v.lang === 'en-US') || voices[0];
                    if (voice) utterance.voice = voice;
                    
                    // Simulate visemes based on word boundaries
                    utterance.onboundary = (e) => {
                        if (e.name === 'word' && this.onViseme) {
                            const word = text.substring(e.charIndex).split(/\s/)[0];
                            const viseme = this.getVisemeForWord(word);
                            this.onViseme(viseme, 0.15);
                        }
                    };
                    
                    utterance.onend = () => {
                        this.isSpeaking = false;
                        if (this.onViseme) this.onViseme('sil', 0);
                        resolve();
                    };
                    
                    utterance.onerror = () => {
                        this.isSpeaking = false;
                        if (this.onViseme) this.onViseme('sil', 0);
                        resolve();
                    };
                    
                    synthesis.speak(utterance);
                });
            }
            
            stop() {
                this.isSpeaking = false;
            }
        }
        
        function VRMAvatarViewer({ side, isDualMode, avatarName }) {
            const canvasRef = useRef(null);
            const vrmRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const ttsRef = useRef(new TTSService());
            const [isLoaded, setIsLoaded] = useState(false);
            const [isSpeaking, setIsSpeaking] = useState(false);
            const animationIdRef = useRef(null);
            
            useEffect(() => {
                let isMounted = true;
                
                const init = () => {
                    if (!window.THREE) {
                        console.log('Waiting for THREE...');
                        return;
                    }
                    
                    const { THREE, GLTFLoader, VRMLoaderPlugin, VRMUtils } = window;
                    if (!canvasRef.current) return;
                    
                    const canvas = canvasRef.current;
                    const width = canvas.clientWidth;
                    const height = canvas.clientHeight;
                    
                    // Scene
                    const scene = new THREE.Scene();
                    sceneRef.current = scene;
                    
                    // Camera - positioned for portrait view of avatar
                    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 1000);
                    camera.position.set(0, 1.1, 2.5);
                    camera.lookAt(0, 1.0, 0);
                    cameraRef.current = camera;
                    
                    // Renderer
                    const renderer = new THREE.WebGLRenderer({
                        canvas, alpha: true, antialias: true
                    });
                    renderer.setSize(width, height);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    renderer.outputColorSpace = THREE.SRGBColorSpace;
                    rendererRef.current = renderer;
                    
                    // Lights
                    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                    scene.add(ambient);
                    
                    const main = new THREE.DirectionalLight(0xffffff, 1.0);
                    main.position.set(2, 3, 2);
                    scene.add(main);
                    
                    const fill = new THREE.DirectionalLight(0x9090ff, 0.3);
                    fill.position.set(-2, 1, 1);
                    scene.add(fill);
                    
                    // Load VRM
                    const loader = new GLTFLoader();
                    loader.register((parser) => new VRMLoaderPlugin(parser));
                    
                    console.log('Loading VRM from:', VRM_URL);
                    
                    loader.load(
                        VRM_URL,
                        (gltf) => {
                            if (!isMounted) return;
                            
                            const vrm = gltf.userData.vrm;
                            vrmRef.current = vrm;
                            
                            console.log('VRM loaded:', vrm);
                            console.log('Expressions:', vrm.expressionManager?.expressions);
                            console.log('Blendshapes:', Object.keys(vrm.expressionManager?._expressionMap || {}));
                            
                            VRMUtils.rotateVRM0(vrm);
                            scene.add(vrm.scene);
                            
                            // Set up lookAt
                            if (vrm.lookAt) {
                                vrm.lookAt.target = camera;
                            }
                            
                            // Set up TTS callback
                            ttsRef.current.onViseme = (viseme, duration) => {
                                applyViseme(viseme);
                            };
                            
                            // Apply neutral pose - relax arms from T-pose
                            if (vrm.humanoid) {
                                try {
                                    // Get raw bone nodes for posing
                                    const leftUpperArm = vrm.humanoid.getRawBoneNode('leftUpperArm');
                                    const rightUpperArm = vrm.humanoid.getRawBoneNode('rightUpperArm');
                                    const leftLowerArm = vrm.humanoid.getRawBoneNode('leftLowerArm');
                                    const rightLowerArm = vrm.humanoid.getRawBoneNode('rightLowerArm');
                                    
                                    // Relax arms down (T-pose has arms out at 90 degrees)
                                    if (leftUpperArm) {
                                        leftUpperArm.rotation.z = Math.PI / 8; // ~22 degrees down
                                        leftUpperArm.rotation.x = 0;
                                    }
                                    if (rightUpperArm) {
                                        rightUpperArm.rotation.z = -Math.PI / 8; // ~22 degrees down
                                        rightUpperArm.rotation.x = 0;
                                    }
                                    if (leftLowerArm) leftLowerArm.rotation.x = -Math.PI / 16;
                                    if (rightLowerArm) rightLowerArm.rotation.x = -Math.PI / 16;
                                    
                                    console.log('Pose applied - arms relaxed');
                                } catch (e) {
                                    console.log('Could not set pose:', e);
                                }
                            }
                            
                            setIsLoaded(true);
                        },
                        (progress) => {
                            const pct = Math.round((progress.loaded / progress.total) * 100);
                            console.log('Loading:', pct + '%');
                        },
                        (error) => {
                            console.error('VRM load error:', error);
                            alert('Failed to load avatar: ' + error.message);
                        }
                    );
                    
                    // Animation loop with idle animations
                    const clock = new THREE.Clock();
                    let blinkTime = 0;
                    let nextBlink = Math.random() * 3 + 2;
                    
                    const animate = () => {
                        if (!isMounted) return;
                        animationIdRef.current = requestAnimationFrame(animate);
                        
                        const delta = clock.getDelta();
                        const time = clock.getElapsedTime();
                        
                        if (vrmRef.current) {
                            vrmRef.current.update(delta);
                            
                            // Idle breathing animation
                            if (vrmRef.current.humanoid) {
                                try {
                                    const breath = Math.sin(time * 2) * 0.02;
                                    const chest = vrmRef.current.humanoid.getNormalizedBoneNode('chest');
                                    const spine = vrmRef.current.humanoid.getNormalizedBoneNode('spine');
                                    if (chest) chest.position.y = breath * 0.5;
                                    if (spine) spine.position.y = breath;
                                } catch (e) {}
                            }
                            
                            // Blinking
                            blinkTime += delta;
                            if (blinkTime > nextBlink) {
                                // Trigger blink
                                if (vrmRef.current.expressionManager) {
                                    vrmRef.current.expressionManager.setValue('blink', 1);
                                    setTimeout(() => {
                                        if (vrmRef.current?.expressionManager) {
                                            vrmRef.current.expressionManager.setValue('blink', 0);
                                        }
                                    }, 150);
                                }
                                blinkTime = 0;
                                nextBlink = Math.random() * 3 + 2;
                            }
                        }
                        
                        renderer.render(scene, camera);
                    };
                    animate();
                    
                    // Resize handler
                    const handleResize = () => {
                        if (!canvas || !camera || !renderer) return;
                        const w = canvas.clientWidth;
                        const h = canvas.clientHeight;
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    };
                    window.addEventListener('resize', handleResize);
                };
                
                if (window.modulesLoaded) {
                    init();
                } else {
                    window.addEventListener('modulesLoaded', init);
                }
                
                return () => {
                    isMounted = false;
                    if (animationIdRef.current) cancelAnimationFrame(animationIdRef.current);
                };
            }, [side]);
            
            const applyViseme = (viseme) => {
                const vrm = vrmRef.current;
                if (!vrm?.expressionManager) return;
                
                // Available expressions in the model
                const exprMap = vrm.expressionManager._expressionMap || {};
                const availableExprs = Object.keys(exprMap);
                
                // Reset all visemes
                const allVisemes = ['aa', 'ih', 'ou', 'E', 'oh', 'PP', 'FF', 'TH', 'DD', 'kk', 'CH', 'SS', 'nn', 'RR',
                                   'aa', 'ih', 'ou', 'e', 'oh'];
                allVisemes.forEach(v => {
                    if (v in exprMap) vrm.expressionManager.setValue(v, 0);
                });
                
                // Apply if not silence
                if (viseme !== 'sil') {
                    // Try different cases
                    const variants = [viseme, viseme.toLowerCase(), viseme.toUpperCase()];
                    let applied = false;
                    
                    for (const v of variants) {
                        if (v in exprMap) {
                            vrm.expressionManager.setValue(v, 0.7);
                            applied = true;
                            break;
                        }
                    }
                    
                    // If no exact match, try mapping to available expressions
                    if (!applied) {
                        // Map visemes to common blendshape names
                        const fallbackMap = {
                            'aa': 'a', 'ih': 'i', 'ou': 'u', 'E': 'e', 'oh': 'o',
                            'PP': 'a', 'FF': 'i', 'TH': 'e', 'DD': 'e',
                            'kk': 'o', 'CH': 'i', 'SS': 'i', 'nn': 'a', 'RR': 'o'
                        };
                        const fallback = fallbackMap[viseme];
                        if (fallback && fallback in exprMap) {
                            vrm.expressionManager.setValue(fallback, 0.5);
                        }
                    }
                }
                
                vrm.expressionManager.update();
            };
            
            const setExpression = (expression) => {
                const vrm = vrmRef.current;
                if (!vrm?.expressionManager) return;
                
                // Reset all
                ['happy', 'angry', 'sad', 'relaxed', 'surprised', 'neutral'].forEach(e => {
                    vrm.expressionManager.setValue(e, 0);
                });
                
                // Apply new
                if (expression !== 'neutral') {
                    vrm.expressionManager.setValue(expression, 1);
                }
                
                vrm.expressionManager.update();
            };
            
            const handleSpeak = async () => {
                const texts = [
                    "What an incredible play!",
                    "The offense is on fire today!",
                    "That defensive stop was crucial!",
                    "The crowd is going wild!",
                    "This game is absolutely thrilling!"
                ];
                const text = texts[Math.floor(Math.random() * texts.length)];
                
                setIsSpeaking(true);
                await ttsRef.current.speak(text);
                setIsSpeaking(false);
            };
            
            return (
                <div className={`vrm-canvas-container ${isDualMode ? 'dual' : ''}`}>
                    <canvas ref={canvasRef} className="vrm-canvas" />
                    
                    {isLoaded && (
                        <>
                            <div className={`status-badge ${isSpeaking ? 'speaking' : ''}`}>
                                {isSpeaking ? 'üîä Speaking...' : '‚úÖ Ready'}
                            </div>
                            
                            <div className="avatar-overlay">
                                <div className="avatar-info">
                                    <h3>{avatarName}</h3>
                                    <p>AI Commentator</p>
                                </div>
                            </div>
                            
                            <div className="avatar-controls">
                                <div className="expression-palette">
                                    {['neutral', 'happy', 'sad', 'angry', 'surprised'].map(exp => (
                                        <button key={exp} onClick={() => setExpression(exp)}>
                                            {exp}
                                        </button>
                                    ))}
                                </div>
                                <button 
                                    className="speak-button" 
                                    onClick={handleSpeak}
                                    disabled={isSpeaking}
                                >
                                    {isSpeaking ? 'üéôÔ∏è Speaking...' : 'üéôÔ∏è Speak'}
                                </button>
                            </div>
                        </>
                    )}
                </div>
            );
        }
        
        function App() {
            const [isDualMode, setIsDualMode] = useState(true);
            const [loading, setLoading] = useState(true);
            
            useEffect(() => {
                const timer = setTimeout(() => setLoading(false), 2000);
                return () => clearTimeout(timer);
            }, []);
            
            return (
                <div className="vrm-container">
                    {loading && (
                        <div className="loading-overlay">
                            <div className="loading-content">
                                <div className="loading-spinner"></div>
                                <div className="loading-text">Loading VRM Avatars...</div>
                                <div className="loading-subtext">Three.js + @pixiv/three-vrm</div>
                            </div>
                        </div>
                    )}
                    
                    <div className="vrm-header">
                        <h1>üç£ Sushi VRM Commentary</h1>
                        <div>
                            <button 
                                className={!isDualMode ? 'active' : ''}
                                onClick={() => setIsDualMode(false)}
                            >
                                Single
                            </button>
                            <button 
                                className={isDualMode ? 'active' : ''}
                                onClick={() => setIsDualMode(true)}
                                style={{ marginLeft: '8px' }}
                            >
                                Dual
                            </button>
                        </div>
                    </div>
                    
                    <div className={`vrm-stage ${isDualMode ? 'dual-mode' : ''}`}>
                        <VRMAvatarViewer side="left" isDualMode={isDualMode} avatarName="Sakura" />
                        {isDualMode && (
                            <VRMAvatarViewer side="right" isDualMode={isDualMode} avatarName="Yuki" />
                        )}
                    </div>
                </div>
            );
        }
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
