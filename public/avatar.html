<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sushi - VRM Commentary Avatars</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #050508;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        #root { width: 100%; height: 100%; }
        
        /* Stream UI Overlays */
        .stream-hud {
            position: absolute; top: 0; left: 0; right: 0; z-index: 100;
            background: linear-gradient(180deg, rgba(10,10,15,0.95) 0%, rgba(10,10,15,0.8) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }
        .hud-top { display: flex; align-items: center; justify-content: space-between; padding: 12px 20px; }
        .hud-scores { display: flex; align-items: center; }
        .hud-team { display: flex; align-items: center; gap: 8px; padding: 4px 12px; background: rgba(255,255,255,0.05); border-radius: 8px; }
        .hud-abbr { font-size: 14px; font-weight: 800; letter-spacing: 1px; }
        .hud-pts { font-size: 32px; font-weight: 900; line-height: 1; min-width: 32px; text-align: center; }
        .hud-sep { font-size: 20px; color: rgba(255,255,255,0.2); padding: 0 10px; font-weight: 200; }
        
        .play-ticker {
            padding: 10px 20px;
            background: linear-gradient(90deg, rgba(255,184,28,0.1), transparent);
            border-top: 1px solid rgba(255,255,255,0.05);
        }
        .ticker-label { font-size: 10px; font-weight: 800; color: #FFB81C; text-transform: uppercase; letter-spacing: 1px; margin-right: 10px; }
        .ticker-desc { font-size: 14px; font-weight: 500; color: rgba(255,255,255,0.8); }

        .vrm-stage {
            position: absolute; inset: 0;
            display: flex;
            background: radial-gradient(circle at center, #1a1a2e 0%, #050508 100%);
        }
        .vrm-canvas-container {
            flex: 1; position: relative;
        }
        .vrm-canvas { width: 100%; height: 100%; display: block; }

        .avatar-label {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            padding: 6px 16px; border-radius: 20px;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 12px; font-weight: 700; color: #feca57;
            white-space: nowrap; transition: all 0.3s;
        }
        .avatar-label.speaking {
            background: rgba(255,107,53,0.3); border-color: #ff6b35;
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 0 20px rgba(255,107,53,0.2);
        }

        .subtitle-box {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 600px;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(10px);
            padding: 16px 24px; border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center; z-index: 200;
            animation: slideUp 0.4s ease-out;
        }
        @keyframes slideUp { from { transform: translate(-50%, 20px); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }
        .subtitle-name { font-size: 11px; font-weight: 800; color: #FFB81C; text-transform: uppercase; margin-bottom: 4px; }
        .subtitle-text { font-size: 16px; line-height: 1.5; color: #fff; }

        .loading-screen {
            position: fixed; inset: 0; z-index: 1000;
            background: #050508;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .spinner { width: 50px; height: 50px; border: 3px solid rgba(255,255,255,0.1); border-top-color: #FFB81C; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        
        window.THREE = THREE;
        window.GLTFLoader = GLTFLoader;
        window.VRMLoaderPlugin = VRMLoaderPlugin;
        window.VRMUtils = VRMUtils;
        window.modulesLoaded = true;
        window.dispatchEvent(new Event('modulesLoaded'));
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        const VRM_URL = 'https://raw.githubusercontent.com/pixiv/three-vrm/release/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';

        // Robust TTS Service
        class TTSService {
            constructor() {
                this.audioContext = null;
                this.onViseme = null;
            }

            async speak(text) {
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.audioContext.state === 'suspended') await this.audioContext.resume();

                try {
                    const res = await fetch('/api/tts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text })
                    });
                    
                    if (!res.ok) throw new Error('TTS API failed');
                    const data = await res.json();
                    
                    if (!data.audio) throw new Error('No audio data received');

                    // Robust base64 decoding
                    const b64Data = data.audio.replace(/\s/g, '');
                    const audioBytes = atob(b64Data);
                    const arrayBuffer = new ArrayBuffer(audioBytes.length);
                    const view = new Uint8Array(arrayBuffer);
                    for (let i = 0; i < audioBytes.length; i++) view[i] = audioBytes.charCodeAt(i);

                    const audioData = await this.audioContext.decodeAudioData(arrayBuffer);
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioData;

                    const analyser = this.audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    source.connect(analyser);
                    analyser.connect(this.audioContext.destination);

                    // Viseme loop
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    const startTime = Date.now();
                    const duration = audioData.duration * 1000;

                    return new Promise(resolve => {
                        const checkViseme = () => {
                            if (Date.now() - startTime > duration) {
                                if (this.onViseme) this.onViseme('sil');
                                return;
                            }
                            analyser.getByteFrequencyData(dataArray);
                            let sum = 0;
                            for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
                            const vol = sum / dataArray.length;
                            
                            if (vol > 20 && this.onViseme) {
                                const visemes = ['aa', 'ih', 'ou', 'E', 'oh'];
                                this.onViseme(visemes[Math.floor(Math.random() * visemes.length)]);
                            } else if (this.onViseme) {
                                this.onViseme('sil');
                            }
                            requestAnimationFrame(checkViseme);
                        };
                        
                        source.onended = () => {
                            if (this.onViseme) this.onViseme('sil');
                            resolve();
                        };
                        
                        source.start(0);
                        checkViseme();
                    });

                } catch (err) {
                    console.warn('Modal TTS failed, using WebSpeech fallback:', err);
                    return this.speakFallback(text);
                }
            }

            speakFallback(text) {
                return new Promise(resolve => {
                    const synth = window.speechSynthesis;
                    const utter = new SpeechSynthesisUtterance(text);
                    utter.onboundary = (e) => {
                        if (e.name === 'word' && this.onViseme) {
                            const visemes = ['aa', 'ih', 'ou', 'E', 'oh'];
                            this.onViseme(visemes[Math.floor(Math.random() * visemes.length)]);
                            setTimeout(() => this.onViseme('sil'), 150);
                        }
                    };
                    utter.onend = resolve;
                    synth.speak(utter);
                });
            }
        }

        function Avatar({ side, avatarName, activeSpeaker, ttsInstance }) {
            const canvasRef = useRef(null);
            const vrmRef = useRef(null);
            const sceneRef = useRef(null);
            const [loaded, setLoaded] = useState(false);

            useEffect(() => {
                let mounted = true;
                const init = () => {
                    if (!window.THREE || !canvasRef.current) return;
                    const { THREE, GLTFLoader, VRMLoaderPlugin, VRMUtils } = window;
                    
                    const scene = new THREE.Scene();
                    sceneRef.current = scene;
                    
                    const camera = new THREE.PerspectiveCamera(35, canvasRef.current.clientWidth / canvasRef.current.clientHeight, 0.1, 1000);
                    camera.position.set(0, 1.3, 2.5);
                    camera.lookAt(0, 1.2, 0);
                    
                    const renderer = new THREE.WebGLRenderer({ canvas: canvasRef.current, alpha: true, antialias: true });
                    renderer.setSize(canvasRef.current.clientWidth, canvasRef.current.clientHeight);
                    renderer.setPixelRatio(window.devicePixelRatio);
                    
                    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                    const dl = new THREE.DirectionalLight(0xffffff, 1.0);
                    dl.position.set(1, 2, 3);
                    scene.add(dl);

                    const loader = new GLTFLoader();
                    loader.register(parser => new VRMLoaderPlugin(parser));
                    loader.load(VRM_URL, gltf => {
                        if (!mounted) return;
                        const vrm = gltf.userData.vrm;
                        vrmRef.current = vrm;
                        VRMUtils.rotateVRM0(vrm);
                        scene.add(vrm.scene);
                        
                        // Relax arms for natural A-pose (Fixing anatomical position)
                        if (vrm.humanoid) {
                            const lArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                            const rArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                            if (lArm) lArm.rotation.z = -1.3; 
                            if (rArm) rArm.rotation.z = 1.3;
                            vrm.humanoid.update();
                        }
                        setLoaded(true);
                    });

                    const clock = new THREE.Clock();
                    const animate = () => {
                        if (!mounted) return;
                        requestAnimationFrame(animate);
                        const delta = clock.getDelta();
                        if (vrmRef.current) {
                            vrmRef.current.update(delta);
                            // Simple breathing
                            if (vrmRef.current.humanoid) {
                                const spine = vrmRef.current.humanoid.getNormalizedBoneNode('spine');
                                if (spine) spine.position.y = Math.sin(clock.elapsedTime * 1.5) * 0.005;
                            }
                        }
                        renderer.render(scene, camera);
                    };
                    animate();

                    const handleResize = () => {
                        camera.aspect = canvasRef.current.clientWidth / canvasRef.current.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(canvasRef.current.clientWidth, canvasRef.current.clientHeight);
                    };
                    window.addEventListener('resize', handleResize);
                };

                if (window.modulesLoaded) init();
                else window.addEventListener('modulesLoaded', init);
                return () => { mounted = false; };
            }, []);

            // Lip sync connection
            useEffect(() => {
                if (activeSpeaker === side && ttsInstance) {
                    ttsInstance.onViseme = (viseme) => {
                        if (!vrmRef.current?.expressionManager) return;
                        const map = vrmRef.current.expressionManager._expressionMap;
                        ['aa', 'ih', 'ou', 'E', 'oh', 'a', 'i', 'u', 'e', 'o'].forEach(v => {
                            if (v in map) vrmRef.current.expressionManager.setValue(v, 0);
                        });
                        if (viseme !== 'sil') {
                            const target = viseme in map ? viseme : (viseme[0] in map ? viseme[0] : null);
                            if (target) vrmRef.current.expressionManager.setValue(target, 0.7);
                        }
                        vrmRef.current.expressionManager.update();
                    };
                }
            }, [activeSpeaker, side, ttsInstance]);

            return (
                <div className="vrm-canvas-container">
                    <canvas ref={canvasRef} className="vrm-canvas" />
                    <div className={`avatar-label ${activeSpeaker === side ? 'speaking' : ''}`}>
                        {avatarName} {activeSpeaker === side ? 'üéôÔ∏è' : ''}
                    </div>
                </div>
            );
        }

        function App() {
            const [sessionId, setSessionId] = useState(null);
            const [game, setGame] = useState(null);
            const [commentary, setCommentary] = useState(null);
            const [activeSpeaker, setActiveSpeaker] = useState(null);
            const [currentText, setCurrentText] = useState("");
            const [currentSpeakerName, setCurrentSpeakerName] = useState("");
            const [loading, setLoading] = useState(true);
            const [lastSeq, setLastSeq] = useState(-1);
            
            const ttsRef = useRef(new TTSService());
            const queueRef = useRef([]);
            const isSpeakingRef = useRef(false);

            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                setSessionId(params.get('session'));
                setTimeout(() => setLoading(false), 2000);
            }, []);

            const processQueue = async () => {
                if (isSpeakingRef.current || queueRef.current.length === 0) return;
                isSpeakingRef.current = true;
                
                while (queueRef.current.length > 0) {
                    const turn = queueRef.current.shift();
                    const side = turn.speaker === 'A' ? 'left' : 'right';
                    
                    setActiveSpeaker(side);
                    setCurrentSpeakerName(turn.name);
                    setCurrentText(turn.text);
                    
                    await ttsRef.current.speak(turn.text);
                    
                    setActiveSpeaker(null);
                    setCurrentText("");
                    await new Promise(r => setTimeout(r, 500)); // Gap between turns
                }
                
                isSpeakingRef.current = false;
            };

            // Poll Game & Commentary
            useEffect(() => {
                if (!sessionId) return;
                const poll = async () => {
                    try {
                        const [gRes, cRes] = await Promise.all([
                            fetch(`/api/sessions/${sessionId}/game`).then(r => r.json()),
                            fetch(`/api/sessions/${sessionId}/commentary/latest`).then(r => r.json())
                        ]);
                        setGame(gRes);
                        
                        if (cRes.turns?.length > 0) {
                            const seq = cRes.play?.seq || cRes.timestamp;
                            if (seq !== lastSeq) {
                                setLastSeq(seq);
                                setCommentary(cRes);
                                queueRef.current = [...cRes.turns];
                                processQueue();
                            }
                        }
                    } catch (e) { console.error(e); }
                };
                poll();
                const itv = setInterval(poll, 8000);
                return () => clearInterval(itv);
            }, [sessionId, lastSeq]);

            if (loading) return <div className="loading-screen"><div className="spinner" /></div>;

            const awayColor = game?.away?.color || '#ff6b35';
            const homeColor = game?.home?.color || '#4a90d9';

            return (
                <div className="relative w-full h-full">
                    {/* HUD */}
                    <div className="stream-hud">
                        <div className="hud-top">
                            <div className="hud-scores">
                                <div className="hud-team" style={{ borderLeft: `4px solid ${awayColor}` }}>
                                    <span className="hud-abbr" style={{ color: awayColor }}>{game?.away?.abbreviation || 'AWY'}</span>
                                    <span className="hud-pts">{game?.away?.score || 0}</span>
                                </div>
                                <span className="hud-sep">:</span>
                                <div className="hud-team" style={{ borderRight: `4px solid ${homeColor}` }}>
                                    <span className="hud-pts">{game?.home?.score || 0}</span>
                                    <span className="hud-abbr" style={{ color: homeColor }}>{game?.home?.abbreviation || 'HME'}</span>
                                </div>
                            </div>
                            <div className="text-xs font-bold text-gray-500">
                                {game?.status?.detail || 'LIVE'}
                            </div>
                        </div>
                        {commentary?.play && (
                            <div className="play-ticker">
                                <span className="ticker-label">Latest Play</span>
                                <span className="ticker-desc">{commentary.play.description}</span>
                            </div>
                        )}
                    </div>

                    {/* Avatars */}
                    <div className="vrm-stage">
                        <Avatar side="left" avatarName={commentary?.commentators?.a?.name || "Sakura"} activeSpeaker={activeSpeaker} ttsInstance={ttsRef.current} />
                        <Avatar side="right" avatarName={commentary?.commentators?.b?.name || "Yuki"} activeSpeaker={activeSpeaker} ttsInstance={ttsRef.current} />
                    </div>

                    {/* Subtitles */}
                    {activeSpeaker && (
                        <div className="subtitle-box">
                            <div className="subtitle-name">{currentSpeakerName}</div>
                            <div className="subtitle-text">{currentText}</div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

            
            return (
                <div className="vrm-container">
                    {loading && (
                        <div className="loading-overlay">
                            <div className="loading-content">
                                <div className="loading-spinner"></div>
                                <div className="loading-text">Loading VRM Avatars...</div>
                                <div className="loading-subtext">Three.js + @pixiv/three-vrm</div>
                            </div>
                        </div>
                    )}
                    
                    <div className="vrm-header">
                        <h1>üç£ Sushi VRM Commentary</h1>
                        <div>
                            <button 
                                className={!isDualMode ? 'active' : ''}
                                onClick={() => setIsDualMode(false)}
                            >
                                Single
                            </button>
                            <button 
                                className={isDualMode ? 'active' : ''}
                                onClick={() => setIsDualMode(true)}
                                style={{ marginLeft: '8px' }}
                            >
                                Dual
                            </button>
                        </div>
                    </div>
                    
                    <div className={`vrm-stage ${isDualMode ? 'dual-mode' : ''}`}>
                        <VRMAvatarViewer side="left" isDualMode={isDualMode} avatarName="Sakura" />
                        {isDualMode && (
                            <VRMAvatarViewer side="right" isDualMode={isDualMode} avatarName="Yuki" />
                        )}
                    </div>
                </div>
            );
        }
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
