<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sushi - VRM Commentary Avatars</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        #root { width: 100%; height: 100%; }
        .vrm-container {
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
        }
        .vrm-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 20px;
            background: rgba(20, 20, 35, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10; backdrop-filter: blur(10px);
        }
        .vrm-header h1 {
            font-size: 20px; font-weight: 600;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .vrm-header button {
            padding: 8px 16px; border: none; border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: #fff;
            cursor: pointer; font-size: 14px; transition: all 0.2s;
        }
        .vrm-header button:hover { background: rgba(255, 255, 255, 0.2); }
        .vrm-header button.active {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000; font-weight: 600;
        }
        .vrm-stage {
            flex: 1; display: flex; position: relative; overflow: hidden;
        }
        .vrm-canvas-container {
            flex: 1; position: relative; overflow: hidden;
        }
        .vrm-canvas-container.dual {
            width: 50%;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        .vrm-canvas-container.dual:last-child { border-right: none; }
        .vrm-canvas { width: 100%; height: 100%; display: block; }
        
        .avatar-overlay {
            position: absolute; bottom: 0; left: 0; right: 0;
            padding: 20px;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            pointer-events: none;
        }
        .avatar-info {
            background: rgba(20, 20, 35, 0.9);
            padding: 12px 16px; border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: inline-block; pointer-events: auto;
        }
        .avatar-info h3 { font-size: 16px; margin-bottom: 4px; color: #feca57; }
        .avatar-info p { font-size: 12px; color: rgba(255, 255, 255, 0.6); }
        
        .avatar-controls {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px;
            align-items: flex-end;
        }
        .expression-palette {
            display: flex; gap: 6px; flex-wrap: wrap;
            justify-content: flex-end; max-width: 220px;
        }
        .expression-palette button {
            padding: 8px 14px; border: none; border-radius: 20px;
            background: rgba(255, 255, 255, 0.1); color: #fff;
            cursor: pointer; font-size: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .expression-palette button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        .expression-palette button.active {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000; font-weight: 600;
        }
        .speak-button {
            padding: 12px 24px; border: none; border-radius: 30px;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000; cursor: pointer; font-size: 14px; font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        .speak-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        .speak-button:disabled {
            opacity: 0.5; cursor: not-allowed; transform: none;
        }
        
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 1000;
        }
        .loading-content { text-align: center; padding: 40px; }
        .loading-spinner {
            width: 80px; height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ff6b6b; border-right-color: #feca57;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 24px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
        .loading-subtext { font-size: 14px; color: rgba(255, 255, 255, 0.5); }
        
        .status-badge {
            position: absolute; top: 20px; left: 20px;
            padding: 6px 12px; border-radius: 20px;
            font-size: 12px; font-weight: 600;
            background: rgba(0, 255, 100, 0.2);
            border: 1px solid rgba(0, 255, 100, 0.4);
            color: #0f0;
        }
        .status-badge.speaking {
            background: rgba(255, 100, 0, 0.2);
            border-color: rgba(255, 100, 0, 0.4);
            color: #fa0;
            animation: pulse 0.5s infinite;
        }
        .status-badge.fallback {
            background: rgba(255, 200, 0, 0.2);
            border-color: rgba(255, 200, 0, 0.4);
            color: #ffcc00;
            top: 50px;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @media (max-aspect-ratio: 3/4) {
            .vrm-stage.dual-mode { flex-direction: column; }
            .vrm-canvas-container.dual {
                width: 100%; height: 50%;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            .vrm-canvas-container.dual:last-child { border-bottom: none; }
            .vrm-header h1 { font-size: 16px; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        
        window.THREE = THREE;
        window.GLTFLoader = GLTFLoader;
        window.VRMLoaderPlugin = VRMLoaderPlugin;
        window.VRMUtils = VRMUtils;
        window.modulesLoaded = true;
        window.dispatchEvent(new Event('modulesLoaded'));
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Working VRM URL - verified with curl
        const VRM_URL = 'https://raw.githubusercontent.com/pixiv/three-vrm/release/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
        
        // Piper TTS Service with real-time lip sync
        class TTSService {
            constructor() {
                this.onViseme = null;
                this.isSpeaking = false;
                this.audioContext = null;
                this.analyser = null;
            }
            
            async initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }
            
            async speak(text, onFallback = null) {
                await this.initAudioContext();
                this.isSpeaking = true;
                
                try {
                    // Call Modal Piper TTS API
                    console.log('Calling Modal Piper TTS:', text);
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text }),
                    });
                    
                    if (!response.ok) {
                        throw new Error(`TTS API returned ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Decode base64 audio
                    const audioBytes = atob(data.audio);
                    const arrayBuffer = new ArrayBuffer(audioBytes.length);
                    const view = new Uint8Array(arrayBuffer);
                    for (let i = 0; i < audioBytes.length; i++) {
                        view[i] = audioBytes.charCodeAt(i);
                    }
                    
                    const audioData = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    // Create audio source
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioData;
                    
                    // Create analyser for lip sync
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    
                    // Connect: source -> analyser -> destination
                    source.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
                    
                    // Start lip sync analysis
                    this.startLipSyncAnalysis(text, audioData.duration);
                    
                    // Play audio
                    source.start(0);
                    
                    // Wait for playback to finish
                    await new Promise((resolve) => {
                        source.onended = () => {
                            this.isSpeaking = false;
                            if (this.onViseme) this.onViseme('sil', 0);
                            resolve();
                        };
                    });
                    
                } catch (err) {
                    console.error('Modal TTS failed, falling back to Web Speech:', err);
                    if (onFallback) onFallback(true);
                    // Fallback to Web Speech API
                    await this.speakWithWebSpeech(text);
                }
            }
            
            startLipSyncAnalysis(text, duration) {
                if (!this.analyser || !this.onViseme) return;
                
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                const words = text.split(/\s+/);
                const startTime = this.audioContext.currentTime;
                const wordsPerSecond = words.length / duration;
                
                const analyze = () => {
                    if (!this.isSpeaking) return;
                    
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    // Calculate volume from frequency data
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i];
                    }
                    const average = sum / dataArray.length;
                    const volume = average / 255;
                    
                    // Map volume to visemes
                    if (volume > 0.15) {
                        const elapsed = this.audioContext.currentTime - startTime;
                        const wordIndex = Math.floor(elapsed * wordsPerSecond);
                        if (wordIndex < words.length) {
                            const word = words[wordIndex];
                            const viseme = this.getVisemeForWord(word);
                            this.onViseme(viseme, 0.1);
                        }
                    } else {
                        this.onViseme('sil', 0.05);
                    }
                    
                    requestAnimationFrame(analyze);
                };
                
                analyze();
            }
            
            getVisemeForWord(word) {
                const char = word.charAt(0).toLowerCase();
                const map = {
                    'a': 'aa', 'e': 'E', 'i': 'ih', 'o': 'oh', 'u': 'ou',
                    'b': 'PP', 'm': 'PP', 'p': 'PP',
                    'f': 'FF', 'v': 'FF',
                    't': 'TH', 'd': 'DD', 's': 'SS',
                    'k': 'kk', 'g': 'kk', 'c': 'kk',
                    'n': 'nn', 'l': 'nn', 'r': 'RR',
                    'w': 'ou', 'y': 'ih'
                };
                return map[char] || 'aa';
            }
            
            async speakWithWebSpeech(text) {
                return new Promise((resolve) => {
                    const synthesis = window.speechSynthesis;
                    if (!synthesis) {
                        this.isSpeaking = false;
                        resolve();
                        return;
                    }
                    
                    synthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.1;
                    utterance.pitch = 1;
                    
                    const voices = synthesis.getVoices();
                    const voice = voices.find(v => v.lang === 'en-US') || voices[0];
                    if (voice) utterance.voice = voice;
                    
                    // Simulate visemes based on word boundaries
                    utterance.onboundary = (e) => {
                        if (e.name === 'word' && this.onViseme) {
                            const word = text.substring(e.charIndex).split(/\s/)[0];
                            const viseme = this.getVisemeForWord(word);
                            this.onViseme(viseme, 0.15);
                        }
                    };
                    
                    utterance.onend = () => {
                        this.isSpeaking = false;
                        if (this.onViseme) this.onViseme('sil', 0);
                        resolve();
                    };
                    
                    utterance.onerror = () => {
                        this.isSpeaking = false;
                        if (this.onViseme) this.onViseme('sil', 0);
                        resolve();
                    };
                    
                    synthesis.speak(utterance);
                });
            }
            
            stop() {
                this.isSpeaking = false;
            }
        }
        
        function VRMAvatarViewer({ side, isDualMode, avatarName, sessionId }) {
            const canvasRef = useRef(null);
            const vrmRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const ttsRef = useRef(new TTSService());
            const [isLoaded, setIsLoaded] = useState(false);
            const [isSpeaking, setIsSpeaking] = useState(false);
            const [lastSeq, setLastSeq] = useState(-1);
            const animationIdRef = useRef(null);
            const turnsQueueRef = useRef([]);
            const isProcessingQueueRef = useRef(false);
            
            // Pose arms down (relax from T-pose)
            const relaxArms = useCallback((vrm) => {
                if (!vrm || !vrm.humanoid) return;
                
                const bones = [
                    { name: 'leftUpperArm', rotation: { z: -0.8, x: 0.1 } },
                    { name: 'rightUpperArm', rotation: { z: 0.8, x: 0.1 } },
                    { name: 'leftLowerArm', rotation: { x: -0.2 } },
                    { name: 'rightLowerArm', rotation: { x: -0.2 } }
                ];
                
                bones.forEach(b => {
                    // Try different cases as some models use different naming
                    const node = vrm.humanoid.getNormalizedBoneNode(b.name) || 
                                vrm.humanoid.getNormalizedBoneNode(b.name.charAt(0).toUpperCase() + b.name.slice(1));
                    
                    if (node) {
                        if (b.rotation.x !== undefined) node.rotation.x = b.rotation.x;
                        if (b.rotation.y !== undefined) node.rotation.y = b.rotation.y;
                        if (b.rotation.z !== undefined) node.rotation.z = b.rotation.z;
                    }
                });
                
                vrm.humanoid.update();
            }, []);

            // Process speech queue
            const processQueue = useCallback(async () => {
                if (isProcessingQueueRef.current || turnsQueueRef.current.length === 0) return;
                
                isProcessingQueueRef.current = true;
                
                while (turnsQueueRef.current.length > 0) {
                    const turn = turnsQueueRef.current.shift();
                    
                    // Only speak if it's our turn
                    const ourSpeakerId = side === 'left' ? 'A' : 'B';
                    if (turn.speaker === ourSpeakerId) {
                        setIsSpeaking(true);
                        try {
                            // Map mood to expression
                            const moodMap = {
                                electric: 'happy',
                                big_play: 'happy',
                                disaster: 'sad',
                                controversial: 'angry',
                                momentum_shift: 'surprised'
                            };
                            if (turn.mood && moodMap[turn.mood]) {
                                setExpression(moodMap[turn.mood]);
                            }

                            await ttsRef.current.speak(turn.text, (fallback) => {
                                if (fallback) setUsingFallbackTTS(true);
                            });
                            
                            // Back to neutral after speaking
                            setExpression('neutral');
                        } catch (e) {
                            console.error('Speech error:', e);
                        }
                        setIsSpeaking(false);
                    } else {
                        // Small delay while the other avatar "speaks"
                        await new Promise(r => setTimeout(r, 1000));
                    }
                }
                
                isProcessingQueueRef.current = false;
            }, [side]);

            // Poll for commentary
            useEffect(() => {
                if (!sessionId || !isLoaded) return;
                
                const poll = async () => {
                    try {
                        const res = await fetch(`/api/sessions/${sessionId}/commentary/latest`);
                        const data = await res.json();
                        
                        if (data.turns && data.turns.length > 0) {
                            const seq = data.play?.seq || data.timestamp;
                            if (seq !== lastSeq) {
                                setLastSeq(seq);
                                // Add all turns to queue with play context
                                turnsQueueRef.current = data.turns.map(t => ({
                                    ...t,
                                    mood: data.play?.mood
                                }));
                                processQueue();
                            }
                        }
                    } catch (err) {
                        console.error('Polling error:', err);
                    }
                };
                
                const interval = setInterval(poll, 5000);
                poll(); // Initial poll
                
                return () => clearInterval(interval);
            }, [sessionId, isLoaded, lastSeq, processQueue]);

            useEffect(() => {
                let isMounted = true;
                
                const init = () => {
                    if (!window.THREE) return;
                    
                    const { THREE, GLTFLoader, VRMLoaderPlugin, VRMUtils } = window;
                    if (!canvasRef.current) return;
                    
                    const canvas = canvasRef.current;
                    const width = canvas.clientWidth;
                    const height = canvas.clientHeight;
                    
                    const scene = new THREE.Scene();
                    sceneRef.current = scene;
                    
                    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 1000);
                    camera.position.set(0, 1.3, 2.5);
                    camera.lookAt(0, 1.2, 0);
                    cameraRef.current = camera;
                    
                    const renderer = new THREE.WebGLRenderer({
                        canvas, alpha: true, antialias: true
                    });
                    renderer.setSize(width, height);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    renderer.outputColorSpace = THREE.SRGBColorSpace;
                    rendererRef.current = renderer;
                    
                    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                    scene.add(ambient);
                    
                    const main = new THREE.DirectionalLight(0xffffff, 1.0);
                    main.position.set(2, 3, 2);
                    scene.add(main);
                    
                    const loader = new GLTFLoader();
                    loader.register((parser) => new VRMLoaderPlugin(parser));
                    
                    loader.load(
                        VRM_URL,
                        (gltf) => {
                            if (!isMounted) return;
                            
                            const vrm = gltf.userData.vrm;
                            vrmRef.current = vrm;
                            
                            VRMUtils.rotateVRM0(vrm);
                            scene.add(vrm.scene);
                            
                            if (vrm.lookAt) vrm.lookAt.target = camera;
                            
                            ttsRef.current.onViseme = (viseme) => applyViseme(viseme);
                            
                            // Relax from T-pose
                            relaxArms(vrm);
                            
                            setIsLoaded(true);
                        },
                        null,
                        (error) => console.error('VRM load error:', error)
                    );
                    
                    const clock = new THREE.Clock();
                    const animate = () => {
                        if (!isMounted) return;
                        animationIdRef.current = requestAnimationFrame(animate);
                        
                        const delta = clock.getDelta();
                        if (vrmRef.current) {
                            vrmRef.current.update(delta);
                            
                            // Idle subtle movement
                            if (vrmRef.current.humanoid) {
                                const t = clock.getElapsedTime();
                                const breath = Math.sin(t * 1.5) * 0.005;
                                const spine = vrmRef.current.humanoid.getNormalizedBoneNode('spine');
                                if (spine) spine.position.y = breath;
                            }
                        }
                        renderer.render(scene, camera);
                    };
                    animate();
                    
                    const handleResize = () => {
                        const w = canvas.clientWidth;
                        const h = canvas.clientHeight;
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    };
                    window.addEventListener('resize', handleResize);
                };
                
                if (window.modulesLoaded) init();
                else window.addEventListener('modulesLoaded', init);
                
                return () => {
                    isMounted = false;
                    if (animationIdRef.current) cancelAnimationFrame(animationIdRef.current);
                };
            }, [side, relaxArms]);
            
            const applyViseme = (viseme) => {
                const vrm = vrmRef.current;
                if (!vrm?.expressionManager) return;
                
                const exprMap = vrm.expressionManager._expressionMap || {};
                
                // Reset common visemes
                ['aa', 'ih', 'ou', 'E', 'oh', 'a', 'i', 'u', 'e', 'o'].forEach(v => {
                    if (v in exprMap) vrm.expressionManager.setValue(v, 0);
                });
                
                if (viseme !== 'sil') {
                    // Try different viseme naming conventions
                    const targets = [viseme, viseme.toLowerCase(), viseme.toUpperCase()];
                    // Fallback to basic vowels
                    const fallbackMap = { 'aa': 'a', 'ih': 'i', 'ou': 'u', 'E': 'e', 'oh': 'o' };
                    if (fallbackMap[viseme]) targets.push(fallbackMap[viseme]);
                    
                    for (const t of targets) {
                        if (t in exprMap) {
                            vrm.expressionManager.setValue(t, 0.7);
                            break;
                        }
                    }
                }
                
                vrm.expressionManager.update();
            };
            
            const setExpression = (expression) => {
                const vrm = vrmRef.current;
                if (!vrm?.expressionManager) return;
                
                ['happy', 'angry', 'sad', 'relaxed', 'surprised', 'neutral'].forEach(e => {
                    if (e in vrm.expressionManager._expressionMap) vrm.expressionManager.setValue(e, 0);
                });
                
                if (expression !== 'neutral' && expression in vrm.expressionManager._expressionMap) {
                    vrm.expressionManager.setValue(expression, 1);
                }
                
                vrm.expressionManager.update();
            };
            
            const [usingFallbackTTS, setUsingFallbackTTS] = useState(false);
            
            const handleSpeakManual = async () => {
                const text = "Checking the voice system. Is Piper working?";
                setIsSpeaking(true);
                setUsingFallbackTTS(false);
                try {
                    await ttsRef.current.speak(text, (fallback) => {
                        if (fallback) setUsingFallbackTTS(true);
                    });
                } catch (e) { console.error(e); }
                setIsSpeaking(false);
            };
            
            return (
                <div className={`vrm-canvas-container ${isDualMode ? 'dual' : ''}`}>
                    <canvas ref={canvasRef} className="vrm-canvas" />
                    
                    {isLoaded && (
                        <>
                            <div className={`status-badge ${isSpeaking ? 'speaking' : ''}`}>
                                {isSpeaking ? 'üîä Speaking...' : '‚úÖ Ready'}
                            </div>
                            
                            {usingFallbackTTS && (
                                <div className="status-badge fallback">
                                    ‚ö†Ô∏è Using Browser TTS
                                </div>
                            )}
                            
                            <div className="avatar-overlay">
                                <div className="avatar-info">
                                    <h3>{avatarName}</h3>
                                    <p>AI Commentator</p>
                                </div>
                            </div>
                            
                            <div className="avatar-controls">
                                <div className="expression-palette">
                                    {['neutral', 'happy', 'sad', 'angry', 'surprised'].map(exp => (
                                        <button key={exp} onClick={() => setExpression(exp)}>
                                            {exp}
                                        </button>
                                    ))}
                                </div>
                                <button 
                                    className="speak-button" 
                                    onClick={handleSpeakManual}
                                    disabled={isSpeaking}
                                >
                                    üéôÔ∏è Test Voice
                                </button>
                            </div>
                        </>
                    )}
                </div>
            );
        }
        
        function App() {
            const [isDualMode, setIsDualMode] = useState(true);
            const [loading, setLoading] = useState(true);
            const [sessionId, setSessionId] = useState(null);
            
            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                setSessionId(params.get('session'));
                const timer = setTimeout(() => setLoading(false), 2000);
                return () => clearTimeout(timer);
            }, []);
            
            return (
                <div className="vrm-container">
                    {loading && (
                        <div className="loading-overlay">
                            <div className="loading-content">
                                <div className="loading-spinner"></div>
                                <div className="loading-text">Loading VRM Avatars...</div>
                                <div className="loading-subtext">Three.js + @pixiv/three-vrm</div>
                            </div>
                        </div>
                    )}
                    
                    <div className="vrm-header">
                        <h1>üç£ Sushi VRM Commentary</h1>
                        <div>
                            <button 
                                className={!isDualMode ? 'active' : ''}
                                onClick={() => setIsDualMode(false)}
                            >
                                Single
                            </button>
                            <button 
                                className={isDualMode ? 'active' : ''}
                                onClick={() => setIsDualMode(true)}
                                style={{ marginLeft: '8px' }}
                            >
                                Dual
                            </button>
                        </div>
                    </div>
                    
                    <div className={`vrm-stage ${isDualMode ? 'dual-mode' : ''}`}>
                        <VRMAvatarViewer side="left" isDualMode={isDualMode} avatarName="Sakura" />
                        {isDualMode && (
                            <VRMAvatarViewer side="right" isDualMode={isDualMode} avatarName="Yuki" />
                        )}
                    </div>
                </div>
            );
        }
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
