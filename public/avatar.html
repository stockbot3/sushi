<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sushi - VRM Cinematic Stream</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #010103; color: #fff; overflow: hidden; height: 100vh;
        }
        #root { width: 100%; height: 100%; position: relative; }
        
        .stream-hud {
            position: absolute; top: 0; left: 0; right: 0; z-index: 100;
            background: linear-gradient(180deg, rgba(10,10,15,0.98) 0%, rgba(10,10,15,0.8) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
        }
        .hud-ticker {
            border-top: 1px solid rgba(255,255,255,0.06);
            padding: 6px 24px 8px;
            background: linear-gradient(135deg, rgba(255,184,28,0.06), rgba(255,107,53,0.03));
        }
        .hud-ticker-label {
            font-size: 9px; font-weight: 800; color: #FFB81C; letter-spacing: 2px; text-transform: uppercase;
        }
        .hud-ticker-text {
            font-size: 13px; color: rgba(255,255,255,0.75); line-height: 1.4;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
        }
        .hud-top { display: flex; align-items: center; justify-content: space-between; padding: 12px 24px; }
        .hud-scores { display: flex; align-items: center; }
        .hud-team { display: flex; align-items: center; gap: 12px; padding: 6px 18px; background: rgba(255,255,255,0.05); border-radius: 12px; }
        .hud-abbr { font-size: 16px; font-weight: 900; letter-spacing: 2px; }
        .hud-pts { font-size: 40px; font-weight: 950; line-height: 1; min-width: 40px; text-align: center; }
        .hud-sep { font-size: 28px; color: rgba(255,255,255,0.15); padding: 0 15px; font-weight: 200; }
        
        .vrm-stage {
            position: absolute; inset: 0; display: flex;
            background: radial-gradient(circle at center, #1a1a2e 0%, #010103 100%);
        }
        .vrm-canvas-container { flex: 1; position: relative; }
        .vrm-canvas { width: 100%; height: 100%; display: block; }

        .subtitle-box {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 800px;
            background: rgba(5,5,10,0.9); backdrop-filter: blur(25px);
            padding: 24px 40px; border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.15);
            text-align: center; z-index: 200;
            box-shadow: 0 30px 60px rgba(0,0,0,0.6);
        }
        .subtitle-name { font-size: 13px; font-weight: 900; color: #FFB81C; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 3px; }
        .subtitle-text { font-size: 20px; line-height: 1.6; color: #fff; font-weight: 600; }

        .start-overlay {
            position: fixed; inset: 0; z-index: 500;
            background: rgba(0,0,0,0.95); display: flex; align-items: center; justify-content: center;
            cursor: pointer;
        }
        .start-btn {
            padding: 28px 56px; border-radius: 60px;
            background: #fff; color: #000; font-weight: 900; font-size: 22px;
            box-shadow: 0 20px 50px rgba(255,184,28,0.5);
            letter-spacing: 2px; transition: all 0.3s;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/", "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js" } } </script>
    <script type="module">
        import * as THREE from 'three'; import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'; import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        window.THREE = THREE; window.GLTFLoader = GLTFLoader; window.VRMLoaderPlugin = VRMLoaderPlugin; window.VRMUtils = VRMUtils;
        window.modulesLoaded = true; window.dispatchEvent(new Event('modulesLoaded'));
    </script>
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const DEFAULT_SAKURA_URL = 'https://raw.githubusercontent.com/pixiv/three-vrm/release/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
        const DEFAULT_YUKI_URL = '/Avatar.vrm';

        const damp = (current, target, lambda, delta) => THREE.MathUtils.damp(current, target, lambda, delta);
        const noise = (t) => Math.sin(t) + Math.sin(t * 2.5) * 0.5;
        const cleanSpeech = (text) => {
            if (!text) return '';
            return text
                .replace(/^\s*(?:\d+[\).\]]|[-•])\s*/g, '')
                .replace(/(^|\n)\s*(?:\d+[\).\]]|[-•])\s*/g, '$1')
                .replace(/^\s*(?:\[?[AB]\]?[:\s—-]+)/i, '')
                .replace(/^\s*[\(\[][^)\]]+[\)\]]\s*:?\s*/g, '')
                .replace(/^\s*[A-Za-z][\w\s-]{0,20}\s*:\s*/g, (m) => {
                    const w = m.replace(':', '').trim();
                    if (w.length <= 20) return '';
                    return m;
                })
                .replace(/^["']|["']$/g, '')
                .replace(/\s*\b\d+\.\s*$/g, '')
                .trim();
        };

        const avatarEvents = {
            listeners: [],
            subscribe(fn) { this.listeners.push(fn); return () => { this.listeners = this.listeners.filter(l => l !== fn); }; },
            emit(side, type, data) { this.listeners.forEach(l => l(side, type, data)); }
        };

        class TTSService {
            constructor() { this.audioContext = null; this.isSpeaking = false; this.isMuted = false; this.isPreGame = false; this.sessionId = null; }
            setMuted(m) { this.isMuted = !!m; }
            setPreGame(p) { this.isPreGame = !!p; }
            setSessionId(s) { this.sessionId = s; }
            async init() {
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.audioContext.state === 'suspended') {
                    try { await this.audioContext.resume(); } catch (e) {}
                }
                const b = this.audioContext.createBuffer(1, 1, 22050);
                const s = this.audioContext.createBufferSource(); s.buffer = b;
                s.connect(this.audioContext.destination); s.start(0);
            }
            async speak(text, side, voice) {
                if (this.isSpeaking) {
                    console.log('[TTS] Already speaking, skipping');
                    return;
                }
                this.isSpeaking = true;
                await this.init();
                if (this.isMuted) {
                    console.log('[TTS] Muted, skipping');
                    this.isSpeaking = false;
                    return;
                }
                try {
                    console.log('[TTS] Fetching audio:', { text: text.substring(0, 30) + '...', voice, isPreGame: this.isPreGame, sessionId: this.sessionId });
                    const res = await fetch('/api/tts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text, voice, isPreGame: this.isPreGame, sessionId: this.sessionId })
                    });

                    if (!res.ok) {
                        console.error('[TTS] Server error:', res.status, res.statusText);
                        throw new Error(`TTS API error: ${res.status}`);
                    }

                    const data = await res.json();
                    console.log('[TTS] Received audio:', { format: data.format, provider: data.provider, hasAudio: !!data.audio });
                    if (!data.audio) throw new Error();

                    // Detect audio format - ElevenLabs returns MP3, Piper returns WAV
                    const audioFormat = data.format || 'wav';
                    const mimeType = audioFormat === 'mp3' ? 'audio/mpeg' : 'audio/wav';

                    const bin = atob(data.audio);
                    const buf = new Uint8Array(bin.length);
                    for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
                    try {
                        const audioBuffer = await this.audioContext.decodeAudioData(buf.buffer);
                        console.log('[TTS] Audio decoded, duration:', audioBuffer.duration.toFixed(2) + 's');
                        const source = this.audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        const analyser = this.audioContext.createAnalyser();
                        analyser.fftSize = 256; source.connect(analyser); analyser.connect(this.audioContext.destination);
                        const dataArray = new Uint8Array(analyser.frequencyBinCount);
                        const duration = audioBuffer.duration * 1000; const start = Date.now();
                        return new Promise(resolve => {
                            let active = true;
                            const loop = () => {
                                if (!active) return;
                                if (Date.now() - start > duration) { active = false; resolve(); return; }
                                analyser.getByteFrequencyData(dataArray);
                                let avg = 0; for(let i=0; i<dataArray.length; i++) avg += dataArray[i];
                                avg /= dataArray.length;
                                avatarEvents.emit(side, 'viseme', { viseme: avg > 25 ? ['aa','ih','ou','E','oh'][Math.floor(Math.random()*5)] : 'sil', volume: avg/255 });
                                requestAnimationFrame(loop);
                            };
                            source.onended = () => { active = false; this.isSpeaking = false; avatarEvents.emit(side, 'viseme', { viseme: 'sil', volume: 0 }); console.log('[TTS] Audio ended'); resolve(); };
                            console.log('[TTS] Starting audio playback');
                            source.start(0); loop();
                        });
                    } catch (err) {
                        // iOS fallback: use HTMLAudioElement if decodeAudioData fails
                        return new Promise((resolve, reject) => {
                            const audio = new Audio(`data:${mimeType};base64,${data.audio}`);
                            audio.volume = this.isMuted ? 0 : 1;
                            let visemeTimer = null;
                            const startViseme = () => {
                                visemeTimer = setInterval(() => {
                                    avatarEvents.emit(side, 'viseme', { viseme: ['aa','ih','ou','E','oh'][Math.floor(Math.random()*5)], volume: 0.6 });
                                }, 90);
                            };
                            const stopViseme = () => {
                                if (visemeTimer) clearInterval(visemeTimer);
                                avatarEvents.emit(side, 'viseme', { viseme: 'sil', volume: 0 });
                            };
                            audio.onended = () => { stopViseme(); this.isSpeaking = false; resolve(); };
                            audio.onerror = () => { stopViseme(); this.isSpeaking = false; reject(); };
                            const playPromise = audio.play();
                            startViseme();
                            if (playPromise && playPromise.catch) {
                                playPromise.catch(() => {
                                    stopViseme();
                                    this.isSpeaking = false;
                                    reject();
                                });
                            }
                        }).catch(() => {
                            this.isSpeaking = false;
                            return new Promise(r => {
                                const u = new SpeechSynthesisUtterance(text);
                                u.onend = r; window.speechSynthesis.speak(u);
                            });
                        });
                    }
                } catch (e) {
                    this.isSpeaking = false;
                    return new Promise(r => {
                        const u = new SpeechSynthesisUtterance(text);
                        u.onend = r; window.speechSynthesis.speak(u);
                    });
                }
            }
        }

        function Avatar({ side, modelUrl, activeSpeaker, debugArms }) {
            const canvasRef = useRef(null), vrmRef = useRef(null), speakerRef = useRef(activeSpeaker), isLoadedRef = useRef(false);
            const basePoseRef = useRef(null);
            const blinkTimerRef = useRef(null);
            const debugArmsRef = useRef(debugArms);
            useEffect(() => { speakerRef.current = activeSpeaker; }, [activeSpeaker]);
            useEffect(() => { debugArmsRef.current = debugArms; }, [debugArms]);

            useEffect(() => {
                basePoseRef.current = null;
                let mounted = true;
                const init = () => {
                    const { THREE, GLTFLoader, VRMLoaderPlugin, VRMUtils } = window;
                    const scene = new THREE.Scene(), cam = new THREE.PerspectiveCamera(30, canvasRef.current.clientWidth / canvasRef.current.clientHeight, 0.1, 1000);
                    cam.position.set(0, 1.35, 2.2); cam.lookAt(0, 1.25, 0);
                    const ren = new THREE.WebGLRenderer({ canvas: canvasRef.current, alpha: true, antialias: true });
                    ren.setSize(canvasRef.current.clientWidth, canvasRef.current.clientHeight); ren.setPixelRatio(window.devicePixelRatio);
                    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                    const key = new THREE.DirectionalLight(0xffeeb1, 1.5); key.position.set(-1, 2, 3); scene.add(key);
                    const rim = new THREE.DirectionalLight(0x4455ff, 2.0); rim.position.set(2, 2, -2); scene.add(rim);

                    const scheduleBlink = () => {
                        if (!mounted || !vrmRef.current?.expressionManager) return;
                        const m = vrmRef.current.expressionManager;
                        const delay = 2000 + Math.random() * 3500;
                        blinkTimerRef.current = setTimeout(() => {
                            m.setValue('blink', 1);
                            setTimeout(() => m.setValue('blink', 0), 140);
                            scheduleBlink();
                        }, delay);
                    };

                    const applyBasePose = (humanoid) => {
                        if (!humanoid || basePoseRef.current) return;
                        const bones = {
                            spine: humanoid.getNormalizedBoneNode('spine'),
                            chest: humanoid.getNormalizedBoneNode('chest'),
                            head: humanoid.getNormalizedBoneNode('head'),
                            lua: humanoid.getNormalizedBoneNode('leftUpperArm'),
                            rua: humanoid.getNormalizedBoneNode('rightUpperArm'),
                            lla: humanoid.getNormalizedBoneNode('leftLowerArm'),
                            rla: humanoid.getNormalizedBoneNode('rightLowerArm'),
                            lhand: humanoid.getNormalizedBoneNode('leftHand'),
                            rhand: humanoid.getNormalizedBoneNode('rightHand'),
                            lshoulder: humanoid.getNormalizedBoneNode('leftShoulder'),
                            rshoulder: humanoid.getNormalizedBoneNode('rightShoulder')
                        };

                        // ========== LOG RAW BONE ROTATIONS BEFORE MODIFICATION ==========
                        console.log('========== VRM MODEL RAW BONE ROTATIONS (DEFAULT POSE) ==========');
                        console.log('[ARMS] Left Upper Arm (raw):', bones.lua ? `X:${bones.lua.rotation.x.toFixed(3)} Y:${bones.lua.rotation.y.toFixed(3)} Z:${bones.lua.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Right Upper Arm (raw):', bones.rua ? `X:${bones.rua.rotation.x.toFixed(3)} Y:${bones.rua.rotation.y.toFixed(3)} Z:${bones.rua.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Left Lower Arm (raw):', bones.lla ? `X:${bones.lla.rotation.x.toFixed(3)} Y:${bones.lla.rotation.y.toFixed(3)} Z:${bones.lla.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Right Lower Arm (raw):', bones.rla ? `X:${bones.rla.rotation.x.toFixed(3)} Y:${bones.rla.rotation.y.toFixed(3)} Z:${bones.rla.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Left Shoulder (raw):', bones.lshoulder ? `X:${bones.lshoulder.rotation.x.toFixed(3)} Y:${bones.lshoulder.rotation.y.toFixed(3)} Z:${bones.lshoulder.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Right Shoulder (raw):', bones.rshoulder ? `X:${bones.rshoulder.rotation.x.toFixed(3)} Y:${bones.rshoulder.rotation.y.toFixed(3)} Z:${bones.rshoulder.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Left Hand (raw):', bones.lhand ? `X:${bones.lhand.rotation.x.toFixed(3)} Y:${bones.lhand.rotation.y.toFixed(3)} Z:${bones.lhand.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Right Hand (raw):', bones.rhand ? `X:${bones.rhand.rotation.x.toFixed(3)} Y:${bones.rhand.rotation.y.toFixed(3)} Z:${bones.rhand.rotation.z.toFixed(3)}` : 'null');
                        console.log('[BODY] Spine (raw):', bones.spine ? `X:${bones.spine.rotation.x.toFixed(3)} Y:${bones.spine.rotation.y.toFixed(3)} Z:${bones.spine.rotation.z.toFixed(3)}` : 'null');
                        console.log('[BODY] Chest (raw):', bones.chest ? `X:${bones.chest.rotation.x.toFixed(3)} Y:${bones.chest.rotation.y.toFixed(3)} Z:${bones.chest.rotation.z.toFixed(3)}` : 'null');
                        console.log('[BODY] Head (raw):', bones.head ? `X:${bones.head.rotation.x.toFixed(3)} Y:${bones.head.rotation.y.toFixed(3)} Z:${bones.head.rotation.z.toFixed(3)}` : 'null');
                        console.log('================================================================');

                        // FIXED: Model is in T-pose (Z:0), bring arms down naturally
                        // Research: Need -1.2 to -1.4 radians (~-70° to -80°) to bring arms from T-pose to sides

                        // Shoulders: neutral
                        if (bones.lshoulder) { bones.lshoulder.rotation.z = 0; bones.lshoulder.rotation.x = 0; }
                        if (bones.rshoulder) { bones.rshoulder.rotation.z = 0; bones.rshoulder.rotation.x = 0; }

                        // Use debug values for arm positions (adjustable with D key)
                        const dbg = debugArmsRef.current;
                        if (bones.lua && dbg) {
                            bones.lua.rotation.x = dbg.lua.x;
                            bones.lua.rotation.y = dbg.lua.y;
                            bones.lua.rotation.z = dbg.lua.z;
                        }
                        if (bones.rua && dbg) {
                            bones.rua.rotation.x = dbg.rua.x;
                            bones.rua.rotation.y = dbg.rua.y;
                            bones.rua.rotation.z = dbg.rua.z;
                        }

                        // Lower arms (elbows)
                        if (bones.lla && dbg) {
                            bones.lla.rotation.x = dbg.lla.x;
                            bones.lla.rotation.y = dbg.lla.y;
                            bones.lla.rotation.z = dbg.lla.z;
                        }
                        if (bones.rla && dbg) {
                            bones.rla.rotation.x = dbg.rla.x;
                            bones.rla.rotation.y = dbg.rla.y;
                            bones.rla.rotation.z = dbg.rla.z;
                        }

                        // Hands
                        if (bones.lhand && dbg) {
                            bones.lhand.rotation.x = dbg.lh.x;
                            bones.lhand.rotation.y = dbg.lh.y;
                            bones.lhand.rotation.z = dbg.lh.z;
                        }
                        if (bones.rhand && dbg) {
                            bones.rhand.rotation.x = dbg.rh.x;
                            bones.rhand.rotation.y = dbg.rh.y;
                            bones.rhand.rotation.z = dbg.rh.z;
                        }

                        // Body: Natural posture
                        if (bones.spine) bones.spine.rotation.x = 0.02;
                        if (bones.chest) bones.chest.rotation.x = 0.01;

                        // ========== LOG WHAT WE SET THEM TO ==========
                        console.log('========== VRM BONE ROTATIONS AFTER MY MODIFICATIONS ==========');
                        console.log('[ARMS] Left Upper Arm (SET):', bones.lua ? `X:${bones.lua.rotation.x.toFixed(3)} Y:${bones.lua.rotation.y.toFixed(3)} Z:${bones.lua.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Right Upper Arm (SET):', bones.rua ? `X:${bones.rua.rotation.x.toFixed(3)} Y:${bones.rua.rotation.y.toFixed(3)} Z:${bones.rua.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Left Lower Arm (SET):', bones.lla ? `X:${bones.lla.rotation.x.toFixed(3)} Y:${bones.lla.rotation.y.toFixed(3)} Z:${bones.lla.rotation.z.toFixed(3)}` : 'null');
                        console.log('[ARMS] Right Lower Arm (SET):', bones.rla ? `X:${bones.rla.rotation.x.toFixed(3)} Y:${bones.rla.rotation.y.toFixed(3)} Z:${bones.rla.rotation.z.toFixed(3)}` : 'null');
                        console.log('================================================================');

                        const rot = (b) => b ? { x: b.rotation.x, y: b.rotation.y, z: b.rotation.z } : null;
                        basePoseRef.current = {
                            spine: rot(bones.spine),
                            chest: rot(bones.chest),
                            head: rot(bones.head),
                            lua: rot(bones.lua),
                            rua: rot(bones.rua),
                            lla: rot(bones.lla),
                            rla: rot(bones.rla),
                            lhand: rot(bones.lhand),
                            rhand: rot(bones.rhand)
                        };
                    };

                    new GLTFLoader().register(p => new VRMLoaderPlugin(p)).load(modelUrl || (side === 'left' ? DEFAULT_SAKURA_URL : DEFAULT_YUKI_URL), gltf => {
                        if (!mounted) return;
                        const vrm = gltf.userData.vrm;
                        if (vrm) {
                            vrmRef.current = vrm; VRMUtils.rotateVRM0(vrm); scene.add(vrm.scene);
                            if (vrm.humanoid) applyBasePose(vrm.humanoid);
                        } else { scene.add(gltf.scene); }
                        isLoadedRef.current = true;
                        scheduleBlink();
                    });

                    const clock = new THREE.Clock();
                    const animate = () => {
                        if (!mounted) return; requestAnimationFrame(animate);
                        const dt = Math.min(clock.getDelta(), 0.05), time = clock.getElapsedTime();
                        if (vrmRef.current && isLoadedRef.current) {
                            vrmRef.current.update(dt);
                            const h = vrmRef.current.humanoid;
                            if (h && basePoseRef.current) {
                                const spine = h.getNormalizedBoneNode('spine'),
                                    chest = h.getNormalizedBoneNode('chest'),
                                    head = h.getNormalizedBoneNode('head'),
                                    lua = h.getNormalizedBoneNode('leftUpperArm'),
                                    rua = h.getNormalizedBoneNode('rightUpperArm'),
                                    lla = h.getNormalizedBoneNode('leftLowerArm'),
                                    rla = h.getNormalizedBoneNode('rightLowerArm'),
                                    lhand = h.getNormalizedBoneNode('leftHand'),
                                    rhand = h.getNormalizedBoneNode('rightHand');

                                const isSpeaking = speakerRef.current === side;

                                // Base animation layers
                                const sway = noise(time * 0.35) * 0.02;
                                const breath = Math.sin(time * 1.2) * 0.015;
                                const breathSlow = Math.sin(time * 0.7) * 0.01;

                                // SMOOTH REALISTIC GESTURES with PROPER ELBOW BENDING (Y and Z axes)
                                const gesturePhase = time * 1.8;
                                const emphasisCycle = Math.floor(time / 3) % 3; // Cycle through 3 gesture types

                                let gestureL = { shoulderZ: 0, shoulderX: 0, elbowY: 0, elbowZ: 0, handZ: 0, handX: 0, handY: 0 };
                                let gestureR = { shoulderZ: 0, shoulderX: 0, elbowY: 0, elbowZ: 0, handZ: 0, handX: 0, handY: 0 };

                                if (isSpeaking) {
                                    // Smooth wave functions with easing
                                    const wave1 = Math.sin(gesturePhase);
                                    const wave2 = Math.sin(gesturePhase * 0.7 + 0.5);
                                    const wave3 = Math.sin(gesturePhase * 1.3);

                                    // Add organic variation
                                    const noiseL = noise(time * 0.5) * 0.08;
                                    const noiseR = noise(time * 0.5 + 50) * 0.08;

                                    if (emphasisCycle === 0) {
                                        // Pattern 1: Expressive open gestures - Use Y and Z for elbow bend
                                        gestureL = {
                                            shoulderZ: 0.4 + wave1 * 0.25 + noiseL,
                                            shoulderX: -0.15 + wave2 * 0.1,
                                            elbowY: -0.6 + wave1 * 0.3,  // Y-axis: negative bends up/left
                                            elbowZ: 0.4 + wave1 * 0.2,   // Z-axis: positive raises
                                            handZ: wave1 * 0.12 + wave2 * 0.05,
                                            handX: wave2 * 0.08,
                                            handY: wave1 * 0.06
                                        };
                                        gestureR = {
                                            shoulderZ: -0.4 - wave1 * 0.25 + noiseR,
                                            shoulderX: -0.15 - wave2 * 0.1,
                                            elbowY: 0.6 - wave1 * 0.3,   // Mirror Y
                                            elbowZ: -0.4 - wave1 * 0.2,  // Mirror Z
                                            handZ: -wave1 * 0.12 - wave2 * 0.05,
                                            handX: -wave2 * 0.08,
                                            handY: -wave1 * 0.06
                                        };
                                    } else if (emphasisCycle === 1) {
                                        // Pattern 2: Emphatic pointing - Maximum Y/Z bending
                                        const emphasis = wave3;
                                        gestureL = {
                                            shoulderZ: 0.5 + emphasis * 0.3,
                                            shoulderX: -0.2 + emphasis * 0.15,
                                            elbowY: -0.8 + emphasis * 0.4,  // Dramatic Y bend
                                            elbowZ: 0.6 + emphasis * 0.3,   // Dramatic Z raise
                                            handZ: emphasis * 0.15,
                                            handX: emphasis * 0.12,
                                            handY: emphasis * 0.08
                                        };
                                        gestureR = {
                                            shoulderZ: -0.25 - emphasis * 0.15,
                                            shoulderX: -0.1,
                                            elbowY: 0.5 - emphasis * 0.25,
                                            elbowZ: -0.4 - emphasis * 0.2,
                                            handZ: -emphasis * 0.08,
                                            handX: -emphasis * 0.06,
                                            handY: -emphasis * 0.04
                                        };
                                    } else {
                                        // Pattern 3: Natural conversational - Visible Y/Z bending
                                        gestureL = {
                                            shoulderZ: 0.3 + wave2 * 0.18 + noiseL,
                                            shoulderX: -0.12 + wave1 * 0.08,
                                            elbowY: -0.5 + wave2 * 0.3,  // Natural Y bend
                                            elbowZ: 0.3 + wave2 * 0.2,   // Natural Z raise
                                            handZ: wave2 * 0.1 + noiseL * 0.5,
                                            handX: wave1 * 0.07,
                                            handY: wave2 * 0.05
                                        };
                                        gestureR = {
                                            shoulderZ: -0.3 - wave2 * 0.18 + noiseR,
                                            shoulderX: -0.12 - wave1 * 0.08,
                                            elbowY: 0.5 - wave2 * 0.3,   // Mirror Y
                                            elbowZ: -0.3 - wave2 * 0.2,  // Mirror Z
                                            handZ: -wave2 * 0.1 + noiseR * 0.5,
                                            handX: -wave1 * 0.07,
                                            handY: -wave2 * 0.05
                                        };
                                    }
                                } else {
                                    // Idle: Subtle natural breathing movement
                                    const idleWaveL = noise(time * 0.3) * 0.04;
                                    const idleWaveR = noise(time * 0.3 + 50) * 0.04;
                                    const microMovement = Math.sin(time * 0.6) * 0.02;

                                    gestureL = {
                                        shoulderZ: idleWaveL,
                                        shoulderX: microMovement * 0.5,
                                        elbowY: breathSlow * 2,
                                        elbowZ: breathSlow * 1.5,
                                        handZ: breathSlow * 0.5,
                                        handX: microMovement * 0.3,
                                        handY: 0
                                    };
                                    gestureR = {
                                        shoulderZ: idleWaveR,
                                        shoulderX: -microMovement * 0.5,
                                        elbowY: -breathSlow * 2,
                                        elbowZ: -breathSlow * 1.5,
                                        handZ: -breathSlow * 0.5,
                                        handX: -microMovement * 0.3,
                                        handY: 0
                                    };
                                }

                                // REAL-TIME ELBOW LOGGING (every 2 seconds when speaking)
                                if (isSpeaking && Math.floor(time * 0.5) % 2 === 0 && Math.abs(time - Math.floor(time)) < 0.05) {
                                    console.log('[ANIMATION] Elbow rotations:', {
                                        leftElbowY: gestureL.elbowY?.toFixed(3),
                                        leftElbowZ: gestureL.elbowZ?.toFixed(3),
                                        rightElbowY: gestureR.elbowY?.toFixed(3),
                                        rightElbowZ: gestureR.elbowZ?.toFixed(3),
                                        leftElbowBaseY: basePoseRef.current.lla?.y.toFixed(3),
                                        leftElbowBaseZ: basePoseRef.current.lla?.z.toFixed(3),
                                        pattern: emphasisCycle
                                    });
                                }

                                // Apply animations with smooth damping
                                if (spine && basePoseRef.current.spine) {
                                    spine.rotation.x = damp(spine.rotation.x, basePoseRef.current.spine.x + breath * 0.6 + (isSpeaking ? 0.04 : 0), 3, dt);
                                    spine.rotation.y = damp(spine.rotation.y, basePoseRef.current.spine.y + sway * 0.3, 3, dt);
                                    spine.rotation.z = damp(spine.rotation.z, basePoseRef.current.spine.z + sway * 0.2, 3, dt);
                                    spine.position.y = breathSlow * 0.5;
                                }

                                if (chest && basePoseRef.current.chest) {
                                    chest.rotation.x = damp(chest.rotation.x, basePoseRef.current.chest.x + breath * 0.4 + (isSpeaking ? 0.03 : 0), 3, dt);
                                    chest.rotation.y = damp(chest.rotation.y, basePoseRef.current.chest.y + sway * 0.15, 4, dt);
                                }

                                if (head && basePoseRef.current.head) {
                                    const headTurn = isSpeaking ? Math.sin(time * 1.8) * 0.08 : noise(time * 0.5) * 0.04;
                                    const headNod = isSpeaking ? Math.sin(time * 2.2) * 0.06 : Math.sin(time * 0.9) * 0.012;
                                    const headTilt = isSpeaking ? Math.sin(time * 1.5) * 0.04 : noise(time * 0.6 + 20) * 0.02;

                                    head.rotation.y = damp(head.rotation.y, basePoseRef.current.head.y + headTurn + sway * 0.2, 4, dt);
                                    head.rotation.x = damp(head.rotation.x, basePoseRef.current.head.x + headNod, 4, dt);
                                    head.rotation.z = damp(head.rotation.z, basePoseRef.current.head.z + headTilt, 4, dt);
                                }

                                // Left arm - SMOOTH coordinated movement with PROPER elbow bending
                                if (lua && basePoseRef.current.lua) {
                                    lua.rotation.z = damp(lua.rotation.z, basePoseRef.current.lua.z + gestureL.shoulderZ, 3, dt);
                                    lua.rotation.x = damp(lua.rotation.x, basePoseRef.current.lua.x + gestureL.shoulderX, 3, dt);
                                    lua.rotation.y = damp(lua.rotation.y, basePoseRef.current.lua.y + sway * 0.2, 4, dt);
                                }
                                if (lla && basePoseRef.current.lla) {
                                    // Use Y and Z axes for visible elbow bending!
                                    lla.rotation.y = damp(lla.rotation.y, basePoseRef.current.lla.y + gestureL.elbowY, 2.5, dt);
                                    lla.rotation.z = damp(lla.rotation.z, basePoseRef.current.lla.z + gestureL.elbowZ, 2.5, dt);
                                    lla.rotation.x = damp(lla.rotation.x, basePoseRef.current.lla.x, 3.5, dt); // Keep X at base
                                }
                                if (lhand && basePoseRef.current.lhand) {
                                    lhand.rotation.z = damp(lhand.rotation.z, basePoseRef.current.lhand.z + gestureL.handZ, 4, dt);
                                    lhand.rotation.x = damp(lhand.rotation.x, basePoseRef.current.lhand.x + gestureL.handX, 4, dt);
                                    lhand.rotation.y = damp(lhand.rotation.y, basePoseRef.current.lhand.y + gestureL.handY, 4.5, dt);
                                }

                                // Right arm - SMOOTH coordinated movement with PROPER elbow bending (mirror)
                                if (rua && basePoseRef.current.rua) {
                                    rua.rotation.z = damp(rua.rotation.z, basePoseRef.current.rua.z + gestureR.shoulderZ, 3, dt);
                                    rua.rotation.x = damp(rua.rotation.x, basePoseRef.current.rua.x + gestureR.shoulderX, 3, dt);
                                    rua.rotation.y = damp(rua.rotation.y, basePoseRef.current.rua.y - sway * 0.2, 4, dt);
                                }
                                if (rla && basePoseRef.current.rla) {
                                    // Use Y and Z axes for visible elbow bending!
                                    rla.rotation.y = damp(rla.rotation.y, basePoseRef.current.rla.y + gestureR.elbowY, 2.5, dt);
                                    rla.rotation.z = damp(rla.rotation.z, basePoseRef.current.rla.z + gestureR.elbowZ, 2.5, dt);
                                    rla.rotation.x = damp(rla.rotation.x, basePoseRef.current.rla.x, 3.5, dt); // Keep X at base
                                }
                                if (rhand && basePoseRef.current.rhand) {
                                    rhand.rotation.z = damp(rhand.rotation.z, basePoseRef.current.rhand.z + gestureR.handZ, 4, dt);
                                    rhand.rotation.x = damp(rhand.rotation.x, basePoseRef.current.rhand.x + gestureR.handX, 4, dt);
                                    rhand.rotation.y = damp(rhand.rotation.y, basePoseRef.current.rhand.y + gestureR.handY, 4.5, dt);
                                }
                            }
                        }
                        ren.render(scene, cam);
                    };
                    animate();
                };
                if (window.modulesLoaded) init(); else window.addEventListener('modulesLoaded', init);
                return () => {
                    mounted = false;
                    if (blinkTimerRef.current) clearTimeout(blinkTimerRef.current);
                };
            }, [side, modelUrl]);

            useEffect(() => {
                return avatarEvents.subscribe((targetSide, type, data) => {
                    if (targetSide !== side || !vrmRef.current?.expressionManager) return;
                    const m = vrmRef.current.expressionManager, map = m._expressionMap;
                    if (type === 'viseme') {
                        ['aa','ih','ou','E','oh','a','i','u','e','o'].forEach(v => { if (v in map) m.setValue(v, 0); });
                        if (data.viseme !== 'sil') {
                            let t = data.viseme;
                            if (!(t in map)) { const f = { 'aa':'a','ih':'i','ou':'u','E':'e','oh':'o' }; t = f[data.viseme] || data.viseme[0].toLowerCase(); }
                            if (!(t in map)) t = t.toUpperCase();
                            if (t in map) m.setValue(t, data.volume * 2.0);
                        }
                        m.update();
                    }
                });
            }, [side]);

            return <div className="vrm-canvas-container"><canvas ref={canvasRef} className="vrm-canvas" /></div>;
        }

        function App() {
            const [started, setStarted] = useState(false), [game, setGame] = useState(null), [commentary, setCommentary] = useState(null);
            const [activeSpeaker, setActiveSpeaker] = useState(null), [sub, setSub] = useState({ name: "", text: "" });
            const [sessionMeta, setSessionMeta] = useState(null);
            const [muted, setMuted] = useState(false);
            const [isIdle, setIsIdle] = useState(false);
            const [debugOpen, setDebugOpen] = useState(false);
            const [debugArms, setDebugArms] = useState({
                lua: { x: 0.15, y: 0.1, z: -1.3 },
                rua: { x: 0.15, y: -0.1, z: 1.3 },
                lla: { x: -0.6, y: 0.05, z: 0 },
                rla: { x: -0.6, y: -0.05, z: 0 },
                lh: { x: 0, y: 0, z: 0 },
                rh: { x: 0, y: 0, z: 0 }
            });
            const voiceRef = useRef(new TTSService()), queueRef = useRef([]), isProcessingRef = useRef(false), voicedRef = useRef(new Set()), lastSeqRef = useRef(-1);
            const lastActivityRef = useRef(Date.now());
            const idleCheckRef = useRef(null);
            const heartbeatIntervalRef = useRef(null);
            const sessionMetaRef = useRef(null);

            // Toggle debug panel with 'D' key
            useEffect(() => {
                const handleKey = (e) => {
                    if (e.key.toLowerCase() === 'd' && !e.ctrlKey && !e.metaKey) {
                        setDebugOpen(prev => !prev);
                    }
                };
                window.addEventListener('keydown', handleKey);
                return () => window.removeEventListener('keydown', handleKey);
            }, []);

            useEffect(() => {
                // Support both ?session=xxx and /:slug URLs
                let sessionId = new URLSearchParams(window.location.search).get('session');
                const slug = sessionId ? null : window.location.pathname.substring(1); // Remove leading /

                console.log('[SessionMeta] Initial load - sessionId:', sessionId, 'slug:', slug, 'started:', started);
                if (!started || (!sessionId && !slug)) return;

                // Fetch session by ID or slug
                const fetchUrl = sessionId
                    ? '/api/sessions'
                    : `/api/sessions/by-slug/${slug}`;

                fetch(fetchUrl).then(r => r.json()).then(data => {
                    let session;
                    if (sessionId) {
                        // Query param mode: find session by ID
                        console.log('[SessionMeta] Fetched sessions:', data.length);
                        session = data.find(s => s.id === sessionId);
                        if (!session) {
                            console.error('[SessionMeta] Session not found in list!');
                            return;
                        }
                    } else {
                        // Slug mode: direct session response
                        console.log('[SessionMeta] Found session by slug:', data);
                        session = data;
                        sessionId = session.id; // Get session ID from response
                    }

                    console.log('[SessionMeta] Found session:', session);
                    setSessionMeta(session);
                    sessionMetaRef.current = session;

                    // Use sessionId for all API calls
                    const sid = sessionId;
                    initializeSession(sid);
                }).catch(e => console.error('[SessionMeta] Initial load error:', e));

                const initializeSession = (sid) => {
                // Set session ID for TTS caching
                voiceRef.current.setSessionId(sid);

                // Track user activity (mouse, keyboard, touch) - silently update timestamp
                const trackActivity = () => {
                    lastActivityRef.current = Date.now();
                    // Don't log on every mouse movement - too spammy
                };
                window.addEventListener('mousemove', trackActivity);
                window.addEventListener('mousedown', trackActivity);
                window.addEventListener('keydown', trackActivity);
                window.addEventListener('touchstart', trackActivity);
                window.addEventListener('scroll', trackActivity);

                // Send heartbeat ping every 2 minutes ONLY if not idle
                const sendHeartbeat = () => {
                    if (!isIdle) {
                        fetch(`/api/sessions/${sid}/ping`, { method: 'POST' })
                            .then(r => r.json())
                            .then(data => console.log('[Heartbeat] Sent', data))
                            .catch(e => console.error('[Heartbeat] Error:', e));
                    } else {
                        console.log('[Heartbeat] Skipped (user idle)');
                    }
                };
                sendHeartbeat(); // Send immediately
                heartbeatIntervalRef.current = setInterval(sendHeartbeat, 120000); // Every 2 minutes

                // Check for idle every 10 seconds
                const checkIdle = () => {
                    const idleTimeout = (sessionMetaRef.current?.settings?.idleTimeout || 30) * 60 * 1000; // Default 30 min
                    const timeSinceActivity = Date.now() - lastActivityRef.current;
                    if (timeSinceActivity > idleTimeout && !isIdle) {
                        console.log(`[Idle] User idle for ${Math.round(timeSinceActivity / 1000 / 60)} minutes`);
                        setIsIdle(true);
                    }
                };
                idleCheckRef.current = setInterval(checkIdle, 10000); // Every 10s

                const poll = async () => {
                    if (isIdle) return; // Don't poll if idle
                    try {
                        const [g, c, sessions] = await Promise.all([
                            fetch(`/api/sessions/${sid}/game`).then(r => r.json()),
                            fetch(`/api/sessions/${sid}/commentary/latest`).then(r => r.json()),
                            fetch('/api/sessions').then(r => r.json())
                        ]);
                        setGame(g);

                        // Update sessionMeta to pick up voice changes
                        const s = sessions.find(s => s.id === sid);
                        if (s) {
                            console.log('[SessionMeta] Poll refresh - updating sessionMeta');
                            setSessionMeta(s);
                            sessionMetaRef.current = s;
                        } else {
                            console.error('[SessionMeta] Poll - session not found!');
                        }

                        if (c && Array.isArray(c.turns)) {
                            const seq = c.timestamp;
                            if (seq !== lastSeqRef.current) {
                                lastSeqRef.current = seq;
                                setCommentary(c);
                                // Add status to each turn for TTS caching
                                queueRef.current = c.turns.map(t => ({ ...t, status: c.status }));
                                processQueue();
                            }
                        }
                    } catch (e) {
                        console.error('[Poll] Error:', e);
                    }
                };
                poll(); const itv = setInterval(poll, 30000); // Poll every 30s instead of 8s
                return () => {
                    clearInterval(itv);
                    clearInterval(heartbeatIntervalRef.current);
                    clearInterval(idleCheckRef.current);
                    window.removeEventListener('mousemove', trackActivity);
                    window.removeEventListener('mousedown', trackActivity);
                    window.removeEventListener('keydown', trackActivity);
                    window.removeEventListener('touchstart', trackActivity);
                    window.removeEventListener('scroll', trackActivity);
                };
                }; // End initializeSession
            }, [started, isIdle]); // Removed sessionMeta to prevent interval duplication

            const processQueue = async () => {
                if (isProcessingRef.current || queueRef.current.length === 0) return;
                isProcessingRef.current = true;
                while (queueRef.current.length > 0) {
                    const t = queueRef.current.shift();
                    const side = t.speaker === 'A' ? 'left' : 'right';
                    const cleaned = cleanSpeech(t.text);

                    // Set pre-game flag for TTS caching (from turn, not stale state)
                    const isPreGame = t.status === 'pre';
                    voiceRef.current.setPreGame(isPreGame);

                    // Use sessionMetaRef instead of sessionMeta to avoid stale closure
                    const cMeta = sessionMetaRef.current?.commentators?.[t.speaker === 'A' ? 0 : 1];
                    const defaultVoice = side === 'left' ? 'rachel' : 'adam';
                    const voiceToUse = cMeta?.voice || defaultVoice;

                    console.log(`[TTS] Speaking (${isPreGame ? 'PRE-GAME' : 'LIVE'}):`, { side, voice: voiceToUse, text: cleaned.substring(0, 50) + '...' });

                    setSub({ name: t.name, text: cleaned });
                    setActiveSpeaker(side);

                    try {
                        await voiceRef.current.speak(cleaned, side, voiceToUse);
                    } catch (err) {
                        console.error('[TTS] Error:', err);
                    }

                    setActiveSpeaker(null);
                    setSub({ name: "", text: "" });
                    await new Promise(r => setTimeout(r, 1000));
                }
                isProcessingRef.current = false;
            };

            useEffect(() => {
                voiceRef.current.setMuted(muted);
            }, [muted]);

            if (!started) return <div className="start-overlay" onClick={async () => { await voiceRef.current.init(); setStarted(true); }}><div className="start-btn">TAP TO ENTER STREAM</div></div>;

            const handleContinueWatching = () => {
                lastActivityRef.current = Date.now();
                setIsIdle(false);
            };

            if (isIdle) {
                return (
                    <div className="start-overlay" style={{ background: 'rgba(0,0,0,0.95)' }}>
                        <div style={{ textAlign: 'center', padding: '40px' }}>
                            <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#fff', marginBottom: '20px' }}>
                                Are you still watching?
                            </div>
                            <div style={{ fontSize: '14px', color: '#999', marginBottom: '30px' }}>
                                No activity detected for {sessionMeta?.settings?.idleTimeout || 30} minutes
                            </div>
                            <button
                                onClick={handleContinueWatching}
                                style={{
                                    padding: '15px 40px',
                                    fontSize: '16px',
                                    fontWeight: 'bold',
                                    background: '#FFB81C',
                                    color: '#000',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    transition: 'transform 0.2s'
                                }}
                                onMouseEnter={e => e.target.style.transform = 'scale(1.05)'}
                                onMouseLeave={e => e.target.style.transform = 'scale(1)'}
                            >
                                CONTINUE WATCHING
                            </button>
                        </div>
                    </div>
                );
            }

            const cA = sessionMeta?.commentators?.[0], cB = sessionMeta?.commentators?.[1];
            const recentText = (() => {
                if (commentary?.play?.description) return commentary.play.description;
                if (game?.situation?.lastPlay) return game.situation.lastPlay;
                if (game?.status?.detail) return `Status: ${game.status.detail}`;
                return 'Waiting for live updates...';
            })();
            return (
                <div id="root">
                <div className="stream-hud">
                    <div className="hud-top">
                            <div className="hud-scores">
                                <div className="hud-team"><span className="hud-abbr" style={{color: game?.away?.color}}>{game?.away?.abbreviation}</span><span className="hud-pts">{game?.away?.score}</span></div>
                                <span className="hud-sep">:</span>
                                <div className="hud-team"><span className="hud-pts">{game?.home?.score}</span><span className="hud-abbr" style={{color: game?.home?.color}}>{game?.home?.abbreviation}</span></div>
                            </div>
                    </div>
                    <div className="hud-ticker">
                        <div className="hud-ticker-label">Recent Play</div>
                        <div className="hud-ticker-text">{recentText}</div>
                    </div>
                </div>
                <button
                    onClick={async () => { setMuted(m => !m); if (muted) { await voiceRef.current.init(); } }}
                    style={{
                        position: 'absolute', right: 16, top: 86, zIndex: 150,
                        padding: '8px 12px', borderRadius: 10, border: '1px solid rgba(255,255,255,0.15)',
                        background: muted ? 'rgba(239,68,68,0.25)' : 'rgba(255,255,255,0.08)',
                        color: '#fff', fontWeight: 800, fontSize: 10, letterSpacing: 1
                    }}
                >
                    {muted ? 'UNMUTE' : 'MUTE'}
                </button>
                <div className="vrm-stage">
                        <Avatar side="left" modelUrl={cA?.avatarUrl} activeSpeaker={activeSpeaker} debugArms={debugArms} />
                        <Avatar side="right" modelUrl={cB?.avatarUrl} activeSpeaker={activeSpeaker} debugArms={debugArms} />
                    </div>
                    {sub.text && ( <div className="subtitle-box"> <div className="subtitle-name">{sub.name}</div> <div className="subtitle-text">{sub.text}</div> </div> )}

                    {debugOpen && (
                        <div style={{
                            position: 'fixed', right: 16, top: 130, zIndex: 200,
                            background: 'rgba(0,0,0,0.95)', backdropFilter: 'blur(10px)',
                            border: '1px solid rgba(255,255,255,0.2)', borderRadius: 12,
                            padding: 16, width: 320, maxHeight: 'calc(100vh - 150px)',
                            overflowY: 'auto', fontSize: 11, color: '#fff'
                        }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
                                <div style={{ fontWeight: 800, fontSize: 13, letterSpacing: 1 }}>ARM DEBUG (Press D to close)</div>
                                <button onClick={() => {
                                    const values = JSON.stringify(debugArms, null, 2);
                                    navigator.clipboard.writeText(values);
                                    alert('Values copied to clipboard!');
                                }} style={{ padding: '4px 8px', background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.3)', borderRadius: 6, color: '#fff', fontSize: 10 }}>
                                    COPY VALUES
                                </button>
                            </div>

                            {['lua', 'rua', 'lla', 'rla', 'lh', 'rh'].map(bone => {
                                const labels = {
                                    lua: 'Left Upper Arm',
                                    rua: 'Right Upper Arm',
                                    lla: 'Left Lower Arm (Elbow)',
                                    rla: 'Right Lower Arm (Elbow)',
                                    lh: 'Left Hand',
                                    rh: 'Right Hand'
                                };
                                return (
                                    <div key={bone} style={{ marginBottom: 16, paddingBottom: 12, borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                                        <div style={{ fontWeight: 700, marginBottom: 8, color: '#60a5fa' }}>{labels[bone]}</div>
                                        {['x', 'y', 'z'].map(axis => (
                                            <div key={axis} style={{ marginBottom: 6 }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: 2 }}>
                                                    <span style={{ textTransform: 'uppercase', opacity: 0.7 }}>{axis}</span>
                                                    <span style={{ fontFamily: 'monospace', color: '#fbbf24' }}>{debugArms[bone][axis].toFixed(2)}</span>
                                                </div>
                                                <input
                                                    type="range"
                                                    min="-3"
                                                    max="3"
                                                    step="0.05"
                                                    value={debugArms[bone][axis]}
                                                    onChange={(e) => setDebugArms(prev => ({
                                                        ...prev,
                                                        [bone]: { ...prev[bone], [axis]: parseFloat(e.target.value) }
                                                    }))}
                                                    style={{ width: '100%', accentColor: '#60a5fa' }}
                                                />
                                            </div>
                                        ))}
                                    </div>
                                );
                            })}
                        </div>
                    )}
                </div>
            );
        }
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
