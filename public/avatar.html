<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sushi - VRM Commentary Avatars</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        
        #root {
            width: 100%;
            height: 100%;
        }
        
        .vrm-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .vrm-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: rgba(20, 20, 35, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            backdrop-filter: blur(10px);
        }
        
        .vrm-header h1 {
            font-size: 20px;
            font-weight: 600;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .vrm-header button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .vrm-header button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .vrm-header button.active {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000;
            font-weight: 600;
        }
        
        .vrm-stage {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        .vrm-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .vrm-canvas-container.dual {
            width: 50%;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .vrm-canvas-container.dual:last-child {
            border-right: none;
        }
        
        .vrm-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .avatar-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            pointer-events: none;
        }
        
        .avatar-info {
            background: rgba(20, 20, 35, 0.9);
            padding: 12px 16px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: inline-block;
            pointer-events: auto;
        }
        
        .avatar-info h3 {
            font-size: 16px;
            margin-bottom: 4px;
            color: #feca57;
        }
        
        .avatar-info p {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .avatar-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }
        
        .expression-palette {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
            max-width: 220px;
        }
        
        .expression-palette button {
            padding: 8px 14px;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .expression-palette button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .expression-palette button.active {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000;
            font-weight: 600;
        }
        
        .speak-button {
            padding: 12px 24px;
            border: none;
            border-radius: 30px;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: #000;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        .speak-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .speak-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-content {
            text-align: center;
            padding: 40px;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ff6b6b;
            border-right-color: #feca57;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 24px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .loading-subtext {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .loading-progress {
            margin-top: 16px;
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            border-radius: 2px;
            transition: width 0.3s;
            animation: progress 2s ease-in-out infinite;
        }
        
        @keyframes progress {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }
        
        .viseme-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            color: #feca57;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .viseme-indicator.active {
            opacity: 1;
        }
        
        /* Mobile Portrait */
        @media (max-aspect-ratio: 3/4) {
            .vrm-stage.dual-mode {
                flex-direction: column;
            }
            
            .vrm-canvas-container.dual {
                width: 100%;
                height: 50%;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .vrm-canvas-container.dual:last-child {
                border-bottom: none;
            }
            
            .vrm-header h1 {
                font-size: 16px;
            }
            
            .expression-palette {
                max-width: 150px;
            }
            
            .expression-palette button {
                padding: 6px 10px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <!-- Three.js and VRM via Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
        }
    }
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // TTS Service with Lip Sync
        class TTSService {
            constructor() {
                this.synthesis = window.speechSynthesis;
                this.onViseme = null;
                this.isSpeaking = false;
            }
            
            async speak(text) {
                if (!this.synthesis) {
                    console.warn('Speech synthesis not available');
                    return;
                }
                
                this.isSpeaking = true;
                
                return new Promise((resolve) => {
                    // Cancel any ongoing speech
                    this.synthesis.cancel();
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.1;
                    utterance.pitch = 1;
                    utterance.volume = 1;
                    
                    // Get voices and select a good one
                    const voices = this.synthesis.getVoices();
                    const preferredVoice = voices.find(v => 
                        v.name.includes('Samantha') ||
                        v.name.includes('Victoria') ||
                        v.name.includes('Karen') ||
                        (v.lang === 'en-US' && v.name.includes('Female'))
                    ) || voices.find(v => v.lang === 'en-US') || voices[0];
                    
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                    }
                    
                    // Track words for viseme generation
                    const words = text.split(/\s+/);
                    let wordIndex = 0;
                    
                    utterance.onboundary = (e) => {
                        if (e.name === 'word' && this.onViseme && wordIndex < words.length) {
                            const word = words[wordIndex];
                            const viseme = this.getVisemeForWord(word);
                            const duration = Math.max(0.1, word.length * 0.08);
                            this.onViseme(viseme, duration);
                            wordIndex++;
                        }
                    };
                    
                    utterance.onend = () => {
                        this.isSpeaking = false;
                        if (this.onViseme) this.onViseme('sil', 0);
                        resolve();
                    };
                    
                    utterance.onerror = (e) => {
                        console.error('Speech error:', e);
                        this.isSpeaking = false;
                        if (this.onViseme) this.onViseme('sil', 0);
                        resolve();
                    };
                    
                    this.synthesis.speak(utterance);
                });
            }
            
            getVisemeForWord(word) {
                const char = word.charAt(0).toLowerCase();
                const vowels = { 'a': 'aa', 'e': 'E', 'i': 'ih', 'o': 'oh', 'u': 'ou' };
                const consonants = {
                    'b': 'PP', 'm': 'PP', 'p': 'PP',
                    'f': 'FF', 'v': 'FF',
                    't': 'TH', 'd': 'DD',
                    'k': 'kk', 'g': 'kk', 'c': 'kk',
                    'ch': 'CH', 'j': 'CH', 'sh': 'SS',
                    'n': 'nn', 'l': 'nn', 'r': 'RR',
                    's': 'SS', 'z': 'SS',
                    'w': 'ou', 'y': 'ih'
                };
                
                // Check for digraphs first
                const firstTwo = word.substring(0, 2).toLowerCase();
                if (consonants[firstTwo]) return consonants[firstTwo];
                
                return vowels[char] || consonants[char] || 'aa';
            }
            
            stop() {
                if (this.synthesis) {
                    this.synthesis.cancel();
                }
                this.isSpeaking = false;
            }
        }
        
        // VRM Avatar Viewer Component
        function VRMAvatarViewer({ side, isDualMode, modelUrl, avatarName, speakingText }) {
            const canvasRef = useRef(null);
            const vrmRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const ttsRef = useRef(new TTSService());
            const [isLoaded, setIsLoaded] = useState(false);
            const [currentExpression, setCurrentExpression] = useState('neutral');
            const [currentViseme, setCurrentViseme] = useState('sil');
            const visemeTimeoutRef = useRef(null);
            
            // Initialize Three.js and VRM
            useEffect(() => {
                let isMounted = true;
                let animationId;
                
                const init = async () => {
                    try {
                        // Dynamic imports
                        const THREE = await import('three');
                        const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
                        const { VRMLoaderPlugin, VRMUtils } = await import('@pixiv/three-vrm');
                        
                        if (!canvasRef.current || !isMounted) return;
                        
                        const canvas = canvasRef.current;
                        const width = canvas.clientWidth;
                        const height = canvas.clientHeight;
                        
                        // Scene
                        const scene = new THREE.Scene();
                        sceneRef.current = scene;
                        
                        // Camera
                        const camera = new THREE.PerspectiveCamera(30, width / height, 0.1, 1000);
                        camera.position.set(side === 'left' ? 0.2 : -0.2, 1.35, 3.2);
                        camera.lookAt(side === 'left' ? 0.1 : -0.1, 1.2, 0);
                        cameraRef.current = camera;
                        
                        // Renderer
                        const renderer = new THREE.WebGLRenderer({
                            canvas,
                            alpha: true,
                            antialias: true,
                            powerPreference: 'high-performance'
                        });
                        renderer.setSize(width, height);
                        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        renderer.outputColorSpace = THREE.SRGBColorSpace;
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        rendererRef.current = renderer;
                        
                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                        scene.add(ambientLight);
                        
                        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
                        mainLight.position.set(2, 3, 3);
                        mainLight.castShadow = true;
                        mainLight.shadow.mapSize.width = 1024;
                        mainLight.shadow.mapSize.height = 1024;
                        scene.add(mainLight);
                        
                        const fillLight = new THREE.DirectionalLight(0x9090ff, 0.4);
                        fillLight.position.set(-2, 1, 2);
                        scene.add(fillLight);
                        
                        const rimLight = new THREE.DirectionalLight(0xffd700, 0.5);
                        rimLight.position.set(0, 2, -2);
                        scene.add(rimLight);
                        
                        // Load VRM
                        const loader = new GLTFLoader();
                        loader.register((parser) => new VRMLoaderPlugin(parser));
                        
                        loader.load(
                            modelUrl,
                            (gltf) => {
                                if (!isMounted) return;
                                
                                const vrm = gltf.userData.vrm;
                                vrmRef.current = vrm;
                                
                                // Setup VRM
                                VRMUtils.rotateVRM0(vrm);
                                scene.add(vrm.scene);
                                
                                // Configure VRM
                                if (vrm.lookAt) {
                                    vrm.lookAt.target = camera;
                                }
                                
                                // Setup TTS callback
                                ttsRef.current.onViseme = (viseme, duration) => {
                                    setCurrentViseme(viseme);
                                    applyViseme(viseme);
                                    
                                    // Reset viseme after duration
                                    if (visemeTimeoutRef.current) {
                                        clearTimeout(visemeTimeoutRef.current);
                                    }
                                    if (viseme !== 'sil') {
                                        visemeTimeoutRef.current = setTimeout(() => {
                                            applyViseme('sil');
                                            setCurrentViseme('sil');
                                        }, duration * 1000);
                                    }
                                };
                                
                                setIsLoaded(true);
                            },
                            undefined,
                            (error) => {
                                console.error('Error loading VRM:', error);
                            }
                        );
                        
                        // Animation loop
                        const clock = new THREE.Clock();
                        const animate = () => {
                            if (!isMounted) return;
                            animationId = requestAnimationFrame(animate);
                            
                            const delta = clock.getDelta();
                            
                            if (vrmRef.current) {
                                vrmRef.current.update(delta);
                            }
                            
                            renderer.render(scene, camera);
                        };
                        animate();
                        
                        // Resize handler
                        const handleResize = () => {
                            if (!canvas || !camera || !renderer) return;
                            const newWidth = canvas.clientWidth;
                            const newHeight = canvas.clientHeight;
                            camera.aspect = newWidth / newHeight;
                            camera.updateProjectionMatrix();
                            renderer.setSize(newWidth, newHeight);
                        };
                        window.addEventListener('resize', handleResize);
                        
                        return () => {
                            window.removeEventListener('resize', handleResize);
                        };
                        
                    } catch (error) {
                        console.error('Init error:', error);
                    }
                };
                
                init();
                
                return () => {
                    isMounted = false;
                    if (animationId) cancelAnimationFrame(animationId);
                    if (visemeTimeoutRef.current) clearTimeout(visemeTimeoutRef.current);
                    if (rendererRef.current) rendererRef.current.dispose();
                };
            }, [modelUrl, side]);
            
            // Apply viseme to VRM
            const applyViseme = useCallback((viseme) => {
                const vrm = vrmRef.current;
                if (!vrm || !vrm.expressionManager) return;
                
                // Reset all visemes
                const visemes = ['aa', 'ih', 'ou', 'E', 'oh', 'PP', 'FF', 'TH', 'DD', 'kk', 'CH', 'SS', 'nn', 'RR'];
                visemes.forEach(v => {
                    vrm.expressionManager.setValue(v, 0);
                });
                
                // Apply current viseme
                if (viseme !== 'sil' && visemes.includes(viseme)) {
                    vrm.expressionManager.setValue(viseme, 0.7);
                }
                
                vrm.expressionManager.update();
            }, []);
            
            // Set expression
            const setExpression = useCallback((expression) => {
                const vrm = vrmRef.current;
                if (!vrm || !vrm.expressionManager) return;
                
                // Reset all expressions
                const expressions = ['happy', 'angry', 'sad', 'relaxed', 'neutral', 'surprised'];
                expressions.forEach(exp => {
                    vrm.expressionManager.setValue(exp, 0);
                });
                
                // Set new expression
                if (expression !== 'neutral') {
                    vrm.expressionManager.setValue(expression, 0.8);
                }
                
                vrm.expressionManager.update();
                setCurrentExpression(expression);
            }, []);
            
            // Handle speaking
            useEffect(() => {
                if (speakingText && ttsRef.current) {
                    ttsRef.current.speak(speakingText);
                }
            }, [speakingText]);
            
            const handleSpeak = () => {
                const commentaries = [
                    "What an incredible play! The offense is on fire today!",
                    "That defensive stop was absolutely crucial for the momentum.",
                    "The crowd is going wild after that spectacular move!",
                    "This game is living up to all the hype and more!",
                    "You can feel the tension building as we approach the final minutes."
                ];
                const text = commentaries[Math.floor(Math.random() * commentaries.length)];
                ttsRef.current.speak(text);
            };
            
            return (
                <div className={`vrm-canvas-container ${isDualMode ? 'dual' : ''}`}>
                    <canvas 
                        ref={canvasRef}
                        className="vrm-canvas"
                    />
                    
                    {isLoaded && (
                        <>
                            <div className="avatar-overlay">
                                <div className="avatar-info">
                                    <h3>{avatarName}</h3>
                                    <p>AI Sports Commentator</p>
                                </div>
                            </div>
                            
                            <div className="avatar-controls">
                                <div className="expression-palette">
                                    {['neutral', 'happy', 'sad', 'angry', 'surprised', 'relaxed'].map(exp => (
                                        <button
                                            key={exp}
                                            className={currentExpression === exp ? 'active' : ''}
                                            onClick={() => setExpression(exp)}
                                        >
                                            {exp}
                                        </button>
                                    ))}
                                </div>
                                <button className="speak-button" onClick={handleSpeak}>
                                    üéôÔ∏è Speak
                                </button>
                            </div>
                            
                            <div className={`viseme-indicator ${currentViseme !== 'sil' ? 'active' : ''}`}>
                                Viseme: {currentViseme}
                            </div>
                        </>
                    )}
                </div>
            );
        }
        
        // Main App Component
        function App() {
            const [isDualMode, setIsDualMode] = useState(true);
            const [isLoading, setIsLoading] = useState(true);
            const [loadingProgress, setLoadingProgress] = useState(0);
            
            useEffect(() => {
                // Simulate loading progress
                const interval = setInterval(() => {
                    setLoadingProgress(prev => {
                        if (prev >= 100) {
                            clearInterval(interval);
                            setTimeout(() => setIsLoading(false), 500);
                            return 100;
                        }
                        return prev + Math.random() * 15;
                    });
                }, 300);
                
                return () => clearInterval(interval);
            }, []);
            
            return (
                <div className="vrm-container">
                    {isLoading && (
                        <div className="loading-overlay">
                            <div className="loading-content">
                                <div className="loading-spinner"></div>
                                <div className="loading-text">Loading VRM Avatars</div>
                                <div className="loading-subtext">Powered by Three.js + @pixiv/three-vrm</div>
                                <div className="loading-progress">
                                    <div 
                                        className="loading-progress-bar" 
                                        style={{ width: `${Math.min(loadingProgress, 100)}%` }}
                                    ></div>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    <div className="vrm-header">
                        <h1>üç£ Sushi VRM Commentary</h1>
                        <div>
                            <button 
                                className={!isDualMode ? 'active' : ''}
                                onClick={() => setIsDualMode(false)}
                            >
                                Single
                            </button>
                            <button 
                                className={isDualMode ? 'active' : ''}
                                onClick={() => setIsDualMode(true)}
                                style={{ marginLeft: '8px' }}
                            >
                                Dual
                            </button>
                        </div>
                    </div>
                    
                    <div className={`vrm-stage ${isDualMode ? 'dual-mode' : ''}`}>
                        <VRMAvatarViewer 
                            side="left"
                            isDualMode={isDualMode}
                            modelUrl="/vrm-models/alicia.vrm"
                            avatarName="Sakura"
                        />
                        {isDualMode && (
                            <VRMAvatarViewer 
                                side="right"
                                isDualMode={isDualMode}
                                modelUrl="/vrm-models/avatar2.vrm"
                                avatarName="Yuki"
                            />
                        )}
                    </div>
                </div>
            );
        }
        
        // Mount React app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
