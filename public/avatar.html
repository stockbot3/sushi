<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Sushi - Avatar Commentary</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  
  <style>
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      padding: 0; 
      background: #0a0a0f; 
      color: white; 
      font-family: 'Inter', sans-serif;
      overflow: hidden;
    }
    
    @media (orientation: portrait) {
      .avatar-stage { flex-direction: column; justify-content: center; align-items: center; }
      .avatar-wrapper { width: 90vw; height: 50vh; }
      .avatar-wrapper.hidden-portrait { display: none !important; }
      .vs-badge { display: none !important; }
      .avatar-switcher { display: flex !important; }
    }
    
    @media (orientation: landscape) {
      .avatar-stage { flex-direction: row; justify-content: center; align-items: flex-end; gap: 40px; }
      .avatar-wrapper { width: 45vw; height: 70vh; max-width: 400px; }
      .avatar-wrapper.hidden-portrait { display: flex !important; }
      .vs-badge { display: flex !important; }
      .avatar-switcher { display: none !important; }
    }
    
    .avatar-stage { display: flex; padding: 20px; min-height: 60vh; position: relative; }
    .avatar-wrapper { position: relative; display: flex; flex-direction: column; align-items: center; transition: all 0.3s ease; }
    .avatar-wrapper.active { transform: scale(1.02); z-index: 10; }
    .avatar-wrapper.inactive { opacity: 0.6; transform: scale(0.95); }
    .avatar-canvas { width: 100%; height: 100%; border-radius: 16px; overflow: hidden; }
    .avatar-info { text-align: center; margin-top: 12px; padding: 12px 24px; background: rgba(255,255,255,0.05); border-radius: 12px; backdrop-filter: blur(10px); }
    .lip-sync-container { width: 100%; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 8px; overflow: hidden; }
    .lip-sync-bar { height: 100%; background: linear-gradient(90deg, #FFB81C, #FF6B35); width: 0%; transition: width 0.03s linear; }
    .vs-badge { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 60px; height: 60px; background: linear-gradient(135deg, #FFB81C, #FF6B35); border-radius: 50%; align-items: center; justify-content: center; font-weight: 900; font-size: 14px; color: #000; z-index: 5; }
    .subtitle-box { text-align: center; padding: 20px; background: rgba(0,0,0,0.5); border-top: 1px solid rgba(255,255,255,0.1); min-height: 100px; }
    .controls-bar { display: flex; justify-content: center; gap: 12px; padding: 16px; background: rgba(255,255,255,0.03); border-top: 1px solid rgba(255,255,255,0.06); }
    .control-btn { padding: 12px 24px; border-radius: 12px; border: none; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.2s; }
    .control-btn.primary { background: linear-gradient(135deg, #FFB81C, #FF6B35); color: #000; }
    .control-btn.secondary { background: rgba(255,255,255,0.1); color: white; }
    .avatar-switcher { position: fixed; bottom: 140px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 8px; border-radius: 24px; gap: 8px; z-index: 100; }
    .switcher-dot { width: 12px; height: 12px; border-radius: 50%; background: rgba(255,255,255,0.3); cursor: pointer; transition: all 0.2s; }
    .switcher-dot.active { transform: scale(1.2); }
    .ios-start-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; cursor: pointer; }
    .loading-overlay { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.9); border-radius: 16px; z-index: 20; }
    .spinner { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-top-color: #FFB81C; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .error-message { color: #ff4444; text-align: center; padding: 20px; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- Load libraries in order -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;
    
    // TTS Engine
    class TTSEngine {
      constructor() {
        this.synth = window.speechSynthesis;
        this.isInitialized = false;
      }
      
      async init() {
        // iOS requires user interaction to unlock audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) {
          const ctx = new AudioContext();
          if (ctx.state === 'suspended') {
            await ctx.resume();
          }
        }
        this.isInitialized = true;
      }
      
      async speak(text, onProgress) {
        return new Promise((resolve) => {
          this.synth.cancel();
          
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 1.0;
          utterance.pitch = 1.0;
          utterance.volume = 1.0;
          
          // Get voices
          const voices = this.synth.getVoices();
          const goodVoice = voices.find(v => 
            v.name.includes('Google') || 
            v.name.includes('Samantha') ||
            v.lang === 'en-US'
          );
          if (goodVoice) utterance.voice = goodVoice;
          
          let interval;
          if (onProgress) {
            interval = setInterval(() => {
              onProgress(0.3 + Math.random() * 0.7);
            }, 60);
          }
          
          utterance.onend = () => {
            if (interval) clearInterval(interval);
            if (onProgress) onProgress(0);
            resolve();
          };
          
          utterance.onerror = () => {
            if (interval) clearInterval(interval);
            if (onProgress) onProgress(0);
            resolve();
          };
          
          this.synth.speak(utterance);
        });
      }
      
      stop() {
        this.synth.cancel();
      }
    }

    // Simple Avatar using PIXI (works without Live2D)
    function SimpleAvatar({ name, teamColor, isActive, isSpeaking, lipSyncValue, onClick }) {
      const containerRef = useRef(null);
      const [isLoading, setIsLoading] = useState(true);
      const appRef = useRef(null);
      const lipSyncRef = useRef(0);
      
      useEffect(() => {
        lipSyncRef.current = lipSyncValue;
      }, [lipSyncValue]);
      
      useEffect(() => {
        if (!window.PIXI) {
          setTimeout(() => setIsLoading(false), 1000);
          return;
        }
        
        const app = new PIXI.Application({
          width: 400,
          height: 500,
          transparent: true,
          antialias: true,
          resolution: window.devicePixelRatio || 1,
          autoDensity: true
        });
        
        appRef.current = app;
        containerRef.current.appendChild(app.view);
        
        const container = new PIXI.Container();
        app.stage.addChild(container);
        
        // Background hexagon
        const hex = new PIXI.Graphics();
        const color = parseInt(teamColor.replace('#', ''), 16);
        
        // Draw hexagon background
        hex.beginFill(0x1a1a25);
        hex.lineStyle(4, color);
        const size = 140;
        const points = [];
        for (let i = 0; i < 6; i++) {
          const angle = (i * 60 - 30) * Math.PI / 180;
          points.push(200 + size * Math.cos(angle), 220 + size * Math.sin(angle));
        }
        hex.drawPolygon(points);
        hex.endFill();
        container.addChild(hex);
        
        // Character circle
        const circle = new PIXI.Graphics();
        circle.beginFill(color, 0.8);
        circle.drawCircle(200, 200, 70);
        circle.endFill();
        container.addChild(circle);
        
        // Eyes
        const eyes = new PIXI.Graphics();
        eyes.beginFill(0xffffff);
        eyes.drawCircle(175, 185, 12);
        eyes.drawCircle(225, 185, 12);
        eyes.endFill();
        // Pupils
        eyes.beginFill(0x000000);
        eyes.drawCircle(175, 185, 6);
        eyes.drawCircle(225, 185, 6);
        eyes.endFill();
        container.addChild(eyes);
        
        // Mouth (animated)
        const mouth = new PIXI.Graphics();
        container.addChild(mouth);
        
        // Speaking ring
        const ring = new PIXI.Graphics();
        container.addChild(ring);
        
        // Animation
        let time = 0;
        app.ticker.add(() => {
          time += 0.05;
          
          // Animate mouth based on lip-sync
          mouth.clear();
          mouth.beginFill(0x330000);
          const openAmount = lipSyncRef.current * 30;
          mouth.drawEllipse(200, 235, 25, 5 + openAmount);
          mouth.endFill();
          
          // Speaking ring animation
          ring.clear();
          if (lipSyncRef.current > 0.1) {
            ring.lineStyle(3 + lipSyncRef.current * 3, color, 0.3 + lipSyncRef.current * 0.5);
            const ringSize = 150 + lipSyncRef.current * 25;
            const ringPoints = [];
            for (let i = 0; i < 6; i++) {
              const angle = (i * 60 - 30) * Math.PI / 180;
              ringPoints.push(200 + ringSize * Math.cos(angle), 220 + ringSize * Math.sin(angle));
            }
            ring.drawPolygon(ringPoints);
          }
          
          // Breathing animation
          container.scale.set(1 + Math.sin(time) * 0.01);
        });
        
        setIsLoading(false);
        
        return () => {
          app.destroy(true);
        };
      }, [teamColor]);
      
      return (
        <div 
          className={`avatar-wrapper ${isActive ? 'active' : 'inactive'}`}
          onClick={onClick}
        >
          {isLoading && (
            <div className="loading-overlay">
              <div className="spinner"></div>
              <div className="text-gray-400 mt-4 text-sm">Loading {name}...</div>
            </div>
          )}
          <div ref={containerRef} className="avatar-canvas" />
          <div className="avatar-info">
            <div style={{ color: teamColor, fontWeight: 700, fontSize: '16px' }}>{name}</div>
            <div className="text-gray-400 text-xs mt-1">{isSpeaking ? 'Speaking...' : 'Listening'}</div>
            <div className="lip-sync-container">
              <div className="lip-sync-bar" style={{ width: `${lipSyncValue * 100}%` }} />
            </div>
          </div>
        </div>
      );
    }

    // Live2D Avatar with fallback
    function Live2DAvatar({ modelPath, name, teamColor, isActive, isSpeaking, lipSyncValue, onClick }) {
      const [useFallback, setUseFallback] = useState(false);
      const [isLoading, setIsLoading] = useState(true);
      const [error, setError] = useState(null);
      const containerRef = useRef(null);
      const modelRef = useRef(null);
      const appRef = useRef(null);
      const lipSyncRef = useRef(0);
      
      useEffect(() => {
        lipSyncRef.current = lipSyncValue;
      }, [lipSyncValue]);
      
      useEffect(() => {
        let app;
        let model;
        
        const loadLive2D = async () => {
          try {
            // Check if we have all required libraries
            if (!window.PIXI) {
              throw new Error('PIXI not loaded');
            }
            
            // Try to load Live2D - but it might not be available
            // For now, use fallback since Live2D CDN is unreliable
            setTimeout(() => {
              setUseFallback(true);
              setIsLoading(false);
            }, 500);
            
          } catch (err) {
            console.log('Live2D failed, using fallback:', err);
            setUseFallback(true);
            setIsLoading(false);
          }
        };
        
        loadLive2D();
      }, [modelPath]);
      
      // If fallback needed, render simple avatar
      if (useFallback) {
        return (
          <SimpleAvatar
            name={name}
            teamColor={teamColor}
            isActive={isActive}
            isSpeaking={isSpeaking}
            lipSyncValue={lipSyncValue}
            onClick={onClick}
          />
        );
      }
      
      return (
        <div className="loading-overlay">
          <div className="spinner"></div>
          <div className="text-gray-400 mt-4 text-sm">Loading Live2D...</div>
        </div>
      );
    }

    // Main App
    function App() {
      const [session, setSession] = useState(null);
      const [commentary, setCommentary] = useState([]);
      const [currentTurn, setCurrentTurn] = useState(0);
      const [isPlaying, setIsPlaying] = useState(false);
      const [lipSyncA, setLipSyncA] = useState(0);
      const [lipSyncB, setLipSyncB] = useState(0);
      const [currentSpeaker, setCurrentSpeaker] = useState(null);
      const [subtitle, setSubtitle] = useState({ speaker: '', text: 'Tap Play to start commentary' });
      const [showIOSStart, setShowIOSStart] = useState(true);
      const [activeAvatar, setActiveAvatar] = useState('A');
      const [isLandscape, setIsLandscape] = useState(window.innerWidth > window.innerHeight);
      
      const ttsRef = useRef(new TTSEngine());
      
      useEffect(() => {
        const handleResize = () => {
          setIsLandscape(window.innerWidth > window.innerHeight);
        };
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', handleResize);
        return () => {
          window.removeEventListener('resize', handleResize);
          window.removeEventListener('orientationchange', handleResize);
        };
      }, []);
      
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const sessionId = params.get('session');
        if (sessionId) {
          fetch(`/api/sessions/${sessionId}`)
            .then(r => r.json())
            .then(data => setSession(data))
            .catch(console.error);
        }
      }, []);
      
      const handleIOSStart = async () => {
        await ttsRef.current.init();
        setShowIOSStart(false);
      };
      
      const playCommentary = async () => {
        const params = new URLSearchParams(window.location.search);
        const sessionId = params.get('session');
        
        if (!sessionId) return;
        
        try {
          const res = await fetch(`/api/sessions/${sessionId}/commentary/latest`);
          const data = await res.json();
          
          if (data.turns && data.turns.length > 0) {
            setCommentary(data.turns);
            setIsPlaying(true);
            playTurn(0, data.turns);
          } else {
            setSubtitle({ speaker: '', text: 'No commentary yet. Try again soon.' });
          }
        } catch (err) {
          setSubtitle({ speaker: 'Error', text: 'Failed to load commentary' });
        }
      };
      
      const playTurn = async (index, turns) => {
        if (index >= turns.length) {
          setIsPlaying(false);
          setCurrentSpeaker(null);
          setLipSyncA(0);
          setLipSyncB(0);
          setSubtitle({ speaker: '', text: 'Commentary complete' });
          return;
        }
        
        const turn = turns[index];
        setCurrentTurn(index);
        setCurrentSpeaker(turn.speaker);
        setSubtitle({ speaker: turn.name, text: turn.text });
        
        if (!isLandscape) {
          setActiveAvatar(turn.speaker);
        }
        
        await ttsRef.current.speak(turn.text, (intensity) => {
          if (turn.speaker === 'A') {
            setLipSyncA(intensity);
            setLipSyncB(0);
          } else {
            setLipSyncB(intensity);
            setLipSyncA(0);
          }
        });
        
        setLipSyncA(0);
        setLipSyncB(0);
        
        await new Promise(r => setTimeout(r, 600));
        
        if (isPlaying) {
          playTurn(index + 1, turns);
        }
      };
      
      const handlePause = () => {
        setIsPlaying(false);
        ttsRef.current.stop();
        setLipSyncA(0);
        setLipSyncB(0);
      };
      
      const handleSkip = () => {
        ttsRef.current.stop();
      };
      
      const commentatorA = session?.commentators?.[0] || { name: 'Hiyori', team: 'away' };
      const commentatorB = session?.commentators?.[1] || { name: 'Ren', team: 'home' };
      
      const getTeamColor = (team) => team === 'home' ? '#4a90d9' : '#ff6b35';
      
      return (
        <div className="h-screen flex flex-col">
          {showIOSStart && (
            <div className="ios-start-overlay" onClick={handleIOSStart}>
              <div className="text-6xl mb-4">üéôÔ∏è</div>
              <h1 className="text-2xl font-bold mb-2">Avatar Commentary</h1>
              <p className="text-gray-400 mb-8">Tap anywhere to start</p>
              <div className="text-sm text-gray-500">Enables audio on iOS</div>
            </div>
          )}
          
          <div className="bg-white/5 border-b border-white/10 p-4 flex items-center justify-between">
            <a href="/" className="text-gray-400 hover:text-white text-2xl">‚Üê</a>
            <div className="text-center">
              <div className="font-bold">Avatar Mode</div>
              <div className="text-xs text-gray-400">{session?.gameName || 'Live Commentary'}</div>
            </div>
            <div className="w-6"></div>
          </div>
          
          <div className="avatar-stage flex-1">
            <div className="vs-badge">VS</div>
            
            <div className={`avatar-wrapper ${!isLandscape && activeAvatar !== 'A' ? 'hidden-portrait' : ''}`}>
              <Live2DAvatar
                modelPath="/avatars/models/hiyori/hiyori_pro_t11.model3.json"
                name={commentatorA.name}
                teamColor={getTeamColor(commentatorA.team)}
                isActive={currentSpeaker === 'A'}
                isSpeaking={currentSpeaker === 'A'}
                lipSyncValue={lipSyncA}
                onClick={() => setActiveAvatar('A')}
              />
            </div>
            
            <div className={`avatar-wrapper ${!isLandscape && activeAvatar !== 'B' ? 'hidden-portrait' : ''}`}>
              <Live2DAvatar
                modelPath="/avatars/models/ren/ren.model3.json"
                name={commentatorB.name}
                teamColor={getTeamColor(commentatorB.team)}
                isActive={currentSpeaker === 'B'}
                isSpeaking={currentSpeaker === 'B'}
                lipSyncValue={lipSyncB}
                onClick={() => setActiveAvatar('B')}
              />
            </div>
          </div>
          
          <div className="avatar-switcher">
            <div 
              className={`switcher-dot ${activeAvatar === 'A' ? 'active' : ''}`}
              onClick={() => setActiveAvatar('A')}
              style={{ background: activeAvatar === 'A' ? getTeamColor(commentatorA.team) : undefined }}
            />
            <div 
              className={`switcher-dot ${activeAvatar === 'B' ? 'active' : ''}`}
              onClick={() => setActiveAvatar('B')}
              style={{ background: activeAvatar === 'B' ? getTeamColor(commentatorB.team) : undefined }}
            />
          </div>
          
          <div className="subtitle-box">
            <div className="text-yellow-400 text-xs font-bold uppercase tracking-wider mb-1">
              {subtitle.speaker || 'Commentary'}
            </div>
            <div className="text-lg font-medium text-white/90">
              {subtitle.text}
            </div>
          </div>
          
          <div className="controls-bar">
            {!isPlaying ? (
              <button className="control-btn primary" onClick={playCommentary}>
                ‚ñ∂ Play
              </button>
            ) : (
              <button className="control-btn secondary" onClick={handlePause}>
                ‚è∏ Pause
              </button>
            )}
            <button className="control-btn secondary" onClick={handleSkip}>
              ‚è≠ Skip
            </button>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
